/* Native, implemented in Java
 * This allows you to create a fake entity which can be rendered in the world.
 * Import with 'import FakeEntity from Minecraft'
 */
class FakeEntity {
    /*
     * Creates a new fake entity
     * Parameter - Entity (entity): The entity that you want to create into a fake entity
     * Parameter - World (world): The world that the entity is being rendered in
     */
    FakeEntity(entity, world);

    /*
     * Sets the position of the entity with no interpolation
     * Parameter - Pos (pos): The new position of the entity
     */
    fun setPos(pos);

    /*
     * Sets the position of the entity
     * Parameter - Pos (pos): The new position of the entity
     * Parameter - Number (interpolationSteps): The number of interpolation steps to take
     */
    fun setPos(pos, interpolationSteps);

    /*
     * Sets the position of the entity with no interpolation
     * Parameter - Number (x): The new x position of the entity
     * Parameter - Number (y): The new y position of the entity
     * Parameter - Number (z): The new z position of the entity
     */
    fun setPos(x, y, z);

    /*
     * Sets the position of the entity
     * Parameter - Number (x): The new x position of the entity
     * Parameter - Number (y): The new y position of the entity
     * Parameter - Number (z): The new z position of the entity
     * Parameter - Number (interpolationSteps): The number of interpolation steps to take
     */
    fun setPos(x, y, z, interpolationSteps);

    /*
     * Spawns the entity (makes it render in the world)
     */
    fun spawn();

    /*
     * Updates the position and rotation of the entity with no interpolation
     * Parameter - Pos (pos): The new position of the entity
     * Parameter - Number (yaw): The new yaw of the entity
     * Parameter - Number (pitch): The new pitch of the entity
     */
    fun updatePosAndRotation(pos, yaw, pitch);

    /*
     * Updates the position and rotation of the entity
     * Parameter - Pos (pos): The new position of the entity
     * Parameter - Number (yaw): The new yaw of the entity
     * Parameter - Number (pitch): The new pitch of the entity
     * Parameter - Number (interpolationSteps): The number of interpolation steps to take
     */
    fun updatePosAndRotation(pos, yaw, pitch, interpolationSteps);

    /*
     * Sets the pitch of the entity with no interpolation
     * Parameter - Number (pitch): The new pitch of the entity
     */
    fun setPitch(pitch);

    /*
     * Sets the pitch of the entity
     * Parameter - Number (pitch): The new pitch of the entity
     * Parameter - Number (interpolationSteps): The number of interpolation steps to take
     */
    fun setPitch(pitch, interpolationSteps);

    /*
     * Despawns the entity (makes it not render in the world)
     */
    fun despawn();

    /*
     * Sets the world that the entity is being rendered in
     * Parameter - World (world): The world that the entity is being rendered in
     */
    fun setWorld(world);

    /*
     * Sets the body yaw of the entity with no interpolation
     * Parameter - Number (bodyYaw): The new body yaw of the entity
     */
    fun setBodyYaw(bodyYaw);

    /*
     * Sets the body yaw of the entity
     * Parameter - Number (bodyYaw): The new body yaw of the entity
     * Parameter - Number (interpolationSteps): The number of interpolation steps to take
     */
    fun setBodyYaw(bodyYaw, interpolationSteps);

    /*
     * Sets the yaw of the entity with no interpolation
     * Parameter - Number (yaw): The new yaw of the entity
     */
    fun setYaw(yaw);

    /*
     * Sets the yaw of the entity
     * Parameter - Number (yaw): The new yaw of the entity
     * Parameter - Number (interpolationSteps): The number of interpolation steps to take
     */
    fun setYaw(yaw, interpolationSteps);
}

/* Native, implemented in Java
 * This class is mostly used to get data about entities.
 * Import with 'import Entity from Minecraft'
 */
class Entity {
    /*
     * This gets the biome of the entity, this returns the full biome id, so for example 'minecraft:plains'
     * Returns - String: the biome id of the biome the entity is in
     */
    fun getFullBiome();

    /*
     * This gets the age of the entity in ticks
     * Returns - Number: the age of the entity in ticks
     */
    fun getAge();

    /*
     * This gets the nbt of the entity as a map
     * Returns - Map: the nbt of the entity
     */
    fun getNbt();

    /*
     * This gets the world the entity is in
     * Returns - World: the world the entity is in
     */
    fun getWorld();

    /*
     * This checks whether the entity collides with a block at a given position
     * Parameter - Pos (pos): the position to check
     * Parameter - Block (block): the block to check
     * Returns - Boolean: whether the entity collides with the block
     */
    fun collidesWith(pos, block);

    /*
     * This gets the hitbox of the entity in a list containing the two corners of the hitbox, the minimum point and the maximum point
     * Returns - List: the hitbox of the entity
     */
    fun getHitbox();

    /*
     * This gets the full id of the entity, this returns the full id, so for example
     * 'minecraft:cow' you can find all entityNames on
     * [Joa's Entity Property Encyclopedia](https://joakimthorsen.github.io/MCPropertyEncyclopedia/entities.html)
     * Returns - String: the full id of the entity
     */
    fun getFullId();

    /*
     * Returns true if the player is sprinting
     * Returns - Boolean: true if the player is sprinting, false if not
     */
    fun isSprinting();

    /*
     * This gets the id of the entity, this returns the id, so for example 'cow'
     * Returns - String: the id of the entity
     */
    fun getId();

    /*
     * This sets the entity to either start glowing or stop glowing on the client
     * Parameter - Boolean (glowing): the glowing state
     */
    fun setGlowing(glowing);

    /*
     * This gets the entity id number of the entity
     * Returns - Number: the entity id number
     */
    fun getEntityIdNumber();

    /*
     * This checks if the entity is of the given entity id
     * Parameter - String (entityId): the entity id to check
     * Returns - Boolean: true if the entity is of the given entity id
     */
    fun isOf(entityId);

    /*
     * This gets the position of the entity
     * Returns - Pos: the position of the entity
     */
    fun getPos();

    /*
     * This gets the dimension of the entity
     * Returns - String: the dimension id of dimension the entity is in
     */
    fun getDimension();

    /*
     * Returns true if the entity is glowing
     * Returns - Boolean: true if the entity is glowing, false if not
     */
    fun isGlowing();

    /*
     * Returns true if the entity is submerged in water
     * Returns - Boolean: true if the entity is submerged in water, false if not
     */
    fun isSubmergedInWater();

    /*
     * This gets the biome of the entity, this only returns the path, so for example 'plains'
     * Returns - String: the biome id of the biome the entity is in
     */
    fun getBiome();

    /*
     * This gets the block that the entity is currently looking at
     * with a max range of 20 blocks, if there is no block then it will return air
     * Returns - Block: the block that the entity is looking at, containing the position
     */
    fun getLookingAtBlock();

    /*
     * This gets the block that the entity is currently looking at
     * with a specific max range, if there is no block then it will return air
     * Parameter - Number (maxDistance): the max range to ray cast
     * Returns - Block: the block that the entity is looking at, containing the position
     */
    fun getLookingAtBlock(maxDistance);

    /*
     * This gets the position that the entity is currently looking at with a specific max range
     * Parameter - Number (maxDistance): the max range to ray cast
     * Returns - Pos: the position that the entity is looking at, containing the x, y, and z
     */
    fun getLookingAtPos(maxDistance);

    /*
     * Returns true if the entity is in lava
     * Returns - Boolean: true if the entity is in lava, false if not
     */
    fun isInLava();

    /*
     * This gets the custom name of the entity if it has one
     * Returns - String: the custom name of the entity if it has one, otherwise null
     */
    fun getCustomName();

    /*
     * This gets the uuid of the entity
     * Returns - String: the uuid of the entity
     */
    fun getEntityUuid();

    /*
     * Returns true if the entity is touching water
     * Returns - Boolean: true if the entity is touching water, false if not
     */
    fun isTouchingWater();

    /*
     * Returns true if the entity is falling
     * Returns - Boolean: true if the entity is falling, false if not
     */
    fun isFalling();

    /*
     * Returns true if the entity is touching water or rain
     * Returns - Boolean: true if the entity is touching water or rain, false if not
     */
    fun isTouchingWaterOrRain();

    /*
     * This gets the squared distance between the entity and the other entity
     * Parameter - Entity (otherEntity): the other entity
     * Returns - Number: the squared distance between the entities
     */
    fun getSquaredDistanceTo(otherEntity);

    /*
     * This gets the yaw of the entity (horizontal head rotation)
     * Returns - Number: the yaw of the entity, between -180 and 180
     */
    fun getYaw();

    /*
     * This gets the translated name of the entity, for example 'minecraft:pig' would return 'Pig' if your language is in english
     * Returns - String: the translated name of the entity
     */
    fun getTranslatedName();

    /*
     * This gets the x position of the entity
     * Returns - Number: the x position of the entity
     */
    fun getX();

    /*
     * This gets the pitch of the entity (vertical head rotation)
     * Returns - Number: the pitch of the entity, between -90 and 90
     */
    fun getPitch();

    /*
     * This gets the y position of the entity
     * Returns - Number: the y position of the entity
     */
    fun getY();

    /*
     * This gets the z position of the entity
     * Returns - Number: the z position of the entity
     */
    fun getZ();

    /*
     * Returns true if the player is sneaking
     * Returns - Boolean: true if the player is sneaking, false if not
     */
    fun isSneaking();

    /*
     * This gets the distance between the entity and the other entity
     * Parameter - Entity (otherEntity): the other entity
     * Returns - Number: the distance between the entities
     */
    fun getDistanceTo(otherEntity);

    /*
     * Returns true if the entity is on fire
     * Returns - Boolean: true if the entity is on fire, false if not
     */
    fun isOnFire();

    /*
     * Returns true if the entity is on the ground
     * Returns - Boolean: true if the entity is on the ground, false if not
     */
    fun isOnGround();

    /*
     * This converts an entityId into an entity instance
     * Parameter - String (entityId): the entityId to convert to an entity
     * Returns - Entity: the entity instance from the id
     * Throws - Error: ... is not a valid entity
     */
    static fun of(entityId);
}

/* Native, implemented in Java
 * This class extends Screen and so inherits all of their methods too,
 * this class is used to create client side inventory screens.
 * Import with 'import FakeScreen from Minecraft'
 */
class FakeScreen {
    /*
     * Creates a FakeScreen instance with given name and given amount of rows
     * Parameter - String (name): the name of the screen
     * Parameter - Number (rows): the number of rows between 1 - 6
     */
    FakeScreen(name, rows);

    /*
     * Gets the stack for the given slot, if the slot is out of bounds it returns null
     * Parameter - Number (slotNum): the slot number
     * Returns - ItemStack: the stack for the given slot
     */
    fun getStackForSlot(slotNum);

    /*
     * This sets the callback for when a slot is clicked in the inventory
     * Parameter - Function (function): the callback function which must have 3 parameters, which will be passed in when it is called, item, slotNum, action, being ItemStack, Number, and String respectively
     */
    fun onClick(function);

    /*
     * Sets the stack for the given slot, if the slot is out of bounds it won't be set
     * Parameter - Number (slotNum): the slot number
     * Parameter - ItemStack (stack): the stack to set
     */
    fun setStackForSlot(slotNum, stack);
}

/* Native, implemented in Java
 * This class represents recipes in Minecraft.
 * Import with 'import Recipe from Minecraft'
 */
class Recipe {
    /*
     * This returns the crafting type of the recipe
     * Returns - String: the crafting type of the recipe, for example: 'crafting', 'smelting', 'blasting'
     */
    fun getCraftingType();

    /*
     * This returns the full id of the recipe
     * Returns - String: the full id of the recipe
     */
    fun getFullId();

    /*
     * This returns the id of the recipe
     * Returns - String: the id of the recipe
     */
    fun getId();

    /*
     * This returns all the possible ingredients of the recipe
     * Returns - List: list of lists, each inner lists contains possible recipe items
     */
    fun getIngredients();

    /*
     * This returns the output of the recipe
     * Returns - ItemStack: the output of the recipe
     */
    fun getOutput();

    /*
     * This converts a recipe id into a Recipe if it's valid
     * Parameter - String (recipeId): the id of the recipe to convert to a Recipe
     * Returns - Recipe: the recipe instance from the id
     * Throws - Error: Recipe with id ... doesn't exist
     */
    static fun of(recipeId);
}

/* Native, implemented in Java
 * This allows you to get information about the player's current screen.
 * Import with 'import Screen from Minecraft'
 */
class Screen {
    /*
     * Gets the title of the specific screen
     * Returns - String: the screen title as text, this may include formatting, and custom names for the screen if applicable
     */
    fun getTitle();

    /*
     * Gets the name of the specific screen
     * Returns - String: the screen name, if you are in the creative menu it will return the name of the tab you are on
     */
    fun getName();
}

/* Native, implemented in Java
 * This class allows you to create configs for your scripts
 * Import with 'import Config from Minecraft'
 */
class Config {
    /*
     * Resets the config to the default value
     */
    fun resetToDefault();

    /*
     * Gets the value of the config
     * Returns - Value: The value of the config
     */
    fun getValue();

    /*
     * Converts the config into a json value, this will not keep the listeners
     * Returns - Json: The config as a json value
     */
    fun toJson();

    /*
     * Gets the name of the config
     * Returns - String: The name of the config
     */
    fun getName();

    /*
     * Gets the type of the config
     * Returns - String: The type of the config
     */
    fun getType();

    /*
     * Sets the value of the config, if the value is invalid it will not be changed
     * Parameter - Value (value): The new value of the config
     */
    fun setValue(value);

    /*
     * Gets the description of the config
     * Returns - String: The description of the config
     */
    fun getDescription();

    /*
     * Adds a listener to the config, the listener will be called when the config is changed
     * The listener must have one parameter, this is the rule that was changed
     * Parameter - Function (listener): The listener to add
     */
    fun addListener(listener);

    /*
     * Gets the default value of the config
     * Returns - Value: The default value of the config
     */
    fun getDefaultValue();

    /*
     * Gets the optional info of the config
     * Returns - String: The optional info of the config
     */
    fun getOptionalInfo();

    /*
     * Creates a config from a map
     * The map must contain the following keys:
     * 'type' which is the type of the config which can be 'boolean', 'cycle', 'double', 'double_slider', 'integer', 'integer_slider', 'list', or 'string'
     * 'name' which is the name of the config
     * And can optionally contain the following keys:
     * 'description' which is a description of the config
     * 'optional_info' which is an optional info for the config
     * 'default_value' which is the default value of the config
     * 'value' which is the current value of the config
     * 'listener' which is a function that will be called when the config changes, this must have 1 parameter which is the rule that was changed
     * And 'cycle' types must contain the following keys:
     * 'max_length' which is the max length for the input of the config, this must be an integer > 0, default is 32
     * 'cycle_values' which is a list of values that the config can cycle through
     * And slider types must contain the following keys:
     * 'min' which is the minimum value of the slider
     * 'max' which is the maximum value of the slider
     * Parameter - Map (map): The map to create the config from
     * Returns - Config: The config created from the map
     * Throws - Error: Config map must contain a type that is a string, Config map must contain a name that is a string, 'cycle' type must have 'cycle_values' as a list, ... type must have 'min' as a number, ... type must have 'max' as a number, Invalid config type ...
     */
    static fun fromMap(map);

    /*
     * Creates a config from a list of config maps
     * Parameter - List (list): The list of config maps
     * Returns - List: A list of configs created from the list of config maps
     */
    static fun fromListOfMap(list);
}

/* Native, implemented in Java
 * This class allows you to create key binds that can be used, everything is
 * handled for you internally so you just need to regers the key bind and
 * the function you want to run when it is pressed.
 * Import with 'import KeyBind from '
 */
class KeyBind {
    /*
     * Creates a new key bind
     * Parameter - String (keyName): the name of the key
     */
    KeyBind(keyName);

    /*
     * Gets the key bind's key
     * Returns - String: the key bind's key
     */
    fun getKey();

    /*
     * Sets the callback function for the key bind
     * Parameter - Function (callback): the callback function
     */
    fun setCallback(callback);

    /*
     * Sets the key bind to a new key
     * Parameter - String (keyName): the name of the key
     */
    fun setKey(keyName);
}

/* Native, implemented in Java
 * This class represents worlds, and allows you to interact with things inside of them.
 * Import with 'import World from Minecraft'
 */
class World {
    /*
     * Gets the light level at the given position
     * Parameter - Pos (pos): the position of the block
     * Returns - Number: the light level
     */
    fun getLight(pos);

    /*
     * Gets the light level at the given position
     * Parameter - Number (x): the x position of the block
     * Parameter - Number (y): the y position of the block
     * Parameter - Number (z): the z position of the block
     * Returns - Number: the light level
     */
    fun getLight(x, y, z);

    /*
     * Deprecated: You should use 'world.getId()' instead
     * This will get the id of the world
     * Returns - String: the id of the world, for example: 'overworld'
     */
    fun getDimensionName();

    /*
     * This will get the closest player to another entity in the world
     * Parameter - Entity (entity): the entity to get the closest player to
     * Parameter - Number (maxDistance): the maximum distance to search for a player in blocks
     * Returns - Player: the closest player, null if not found
     */
    fun getClosestPlayer(entity, maxDistance);

    /*
     * This will get the full id of the world
     * Returns - String: the full id of the world, for example: 'minecraft:overworld'
     */
    fun getFullId();

    /*
     * This will get the id of the world
     * Returns - String: the id of the world, for example: 'overworld'
     */
    fun getId();

    /*
     * This will get all entities in the world
     * Returns - List: a list of all entities
     */
    fun getAllEntities();

    /*
     * This function gets the block at the given coordinates
     * Parameter - Pos (pos): the position
     * Returns - Block: the block at the given coordinates
     */
    fun getBlockAt(pos);

    /*
     * This function gets the block at the given coordinates
     * Parameter - Number (x): the x coordinate
     * Parameter - Number (y): the y coordinate
     * Parameter - Number (z): the z coordinate
     * Returns - Block: the block at the given coordinates
     */
    fun getBlockAt(x, y, z);

    /*
     * This gets another player from the given username
     * Parameter - String (username): the username of the other player
     * Returns - Player: the other player, null if not found
     */
    fun getOtherPlayer(username);

    /*
     * This will get an entity from the given entity id
     * Parameter - Number (entityId): the entity id
     * Returns - Entity: the entity, null if not found
     */
    fun getEntityFromId(entityId);

    /*
     * Gets the emitted restone power at the given position and direction
     * Parameter - Pos (pos): the position of the block
     * Parameter - String (direction): the direction to check, for example 'north', 'east', 'up', etc.
     * Returns - Number: the emitted redstone power
     */
    fun getEmittedRedstonePower(pos, direction);

    /*
     * Gets the emitted restone power at the given position and direction
     * Parameter - Number (x): the x position of the block
     * Parameter - Number (y): the y position of the block
     * Parameter - Number (z): the z position of the block
     * Parameter - String (direction): the direction to check, for example 'north', 'east', 'up', etc.
     * Returns - Number: the emitted redstone power
     */
    fun getEmittedRedstonePower(x, y, z, direction);

    /*
     * Deprecated: This function is dangerous, use at your own risk
     * This sets a ghost block in the world as if it were a real block, may cause issues
     * Parameter - Block (block): the block to set
     * Parameter - Pos (pos): the position of the block
     */
    fun setGhostBlock(block, pos);

    /*
     * Deprecated: This function is dangerous, use at your own risk
     * This sets a ghost block in the world as if it were a real block, may cause issues
     * Parameter - Block (block): the block to set
     * Parameter - Number (x): the x position of the block
     * Parameter - Number (y): the y position of the block
     * Parameter - Number (z): the z position of the block
     */
    fun setGhostBlock(block, x, y, z);

    /*
     * This will get all other players in the world
     * Returns - List: a list of all other players
     */
    fun getAllOtherPlayers();

    /*
     * This will render a particle in the world, you can find a list of all
     * the particle ids [here](https://minecraft.fandom.com/wiki/Java_Edition_data_values#Particles)
     * Parameter - String (particleId): the id of the particle
     * Parameter - Pos (pos): the position of the particle
     * Throws - Error: Particle Invalid
     */
    fun renderParticle(particleId, pos);

    /*
     * This will render a particle in the world, you can find a list of all
     * the particle ids [here](https://minecraft.fandom.com/wiki/Java_Edition_data_values#Particles)
     * Parameter - String (particleId): the id of the particle
     * Parameter - Number (x): the x position of the particle
     * Parameter - Number (y): the y position of the particle
     * Parameter - Number (z): the z position of the particle
     * Throws - Error: Particle Invalid
     */
    fun renderParticle(particleId, x, y, z);

    /*
     * This will render a particle in the world with a velocity, you can find a list of all
     * the particle ids [here](https://minecraft.fandom.com/wiki/Java_Edition_data_values#Particles)
     * Parameter - String (particleId): the id of the particle
     * Parameter - Pos (pos): the position of the particle
     * Parameter - Number (velX): the velocity of the particle on the x axis
     * Parameter - Number (velY): the velocity of the particle on the y axis
     * Parameter - Number (velZ): the velocity of the particle on the z axis
     * Throws - Error: Particle Invalid
     */
    fun renderParticle(particleId, pos, velX, velY, velZ);

    /*
     * This will get the time of day of the world
     * info on the time of day [here](https://minecraft.fandom.com/wiki/Daylight_cycle)
     * Returns - Number: the time of day of the world, between 0 and 24000
     */
    fun getTimeOfDay();

    /*
     * This will check if the world is currently thundering
     * Returns - Boolean: true if the world is currently thundering
     */
    fun isThundering();

    /*
     * Returns true if the block at the given position is air
     * Parameter - Pos (pos): the position of the block
     * Returns - Boolean: true if the block is air
     */
    fun isAir(pos);

    /*
     * Returns true if the block at the given position is air
     * Parameter - Number (x): the x position of the block
     * Parameter - Number (y): the y position of the block
     * Parameter - Number (z): the z position of the block
     * Returns - Boolean: true if the block is air
     */
    fun isAir(x, y, z);

    /*
     * This will check if the world is currently raining
     * Returns - Boolean: true if the world is currently raining
     */
    fun isRaining();

    /*
     * This gets a list of all block positions between the two positions
     * Parameter - Pos (pos1): the first position
     * Parameter - Pos (pos2): the second position
     * Returns - List: the list of positions
     */
    fun getArea(pos1, pos2);

    /*
     * This gets a list of all blocks (with positions) between the two positions
     * Parameter - Pos (pos1): the first position
     * Parameter - Pos (pos2): the second position
     * Returns - List: the list of blocks
     */
    fun getAreaOfBlocks(pos1, pos2);
}

/* Native, implemented in Java
 * This class allows you to easily read and write config files.
 * Import with 'import ConfigHandler from Minecraft'
 */
class ConfigHandler {
    /*
     * Creates a new ConfigHandler, this is used to read and save configs
     * Parameter - String (name): The name of the config, this will also be the name of the config file
     */
    ConfigHandler(name);

    /*
     * Creates a new ConfigHandler, this is used to read and save configs
     * Parameter - String (name): The name of the config, this will also be the name of the config file
     * Parameter - Boolean (read): Whether or not to read the config on creation
     */
    ConfigHandler(name, read);

    /*
     * Creates a new config screen containing all of the configs in the handler, in alphabetical order
     * Parameter - Text (title): The title of the screen
     * Returns - Screen: The new config screen
     */
    fun createScreen(title);

    /*
     * Creates a new config screen containing all of the configs in the handler
     * Parameter - Text (title): The title of the screen
     * Parameter - Boolean (alphabetical): Whether or not to sort the configs alphabetically
     * Returns - Screen: The new config screen
     */
    fun createScreen(title, alphabetical);

    /*
     * Resets all configs to their default values
     */
    fun resetAllToDefault();

    /*
     * Sets the path to save the configs to, this shouldn't include the file name
     * Parameter - File (savePath): The path to save the configs to
     */
    fun setSavePath(savePath);

    /*
     * Reads the all the configs from the file
     * If configs are already in the handler, only the values
     * will be overwritten
     */
    fun read();

    /*
     * Gets the name of the config
     * Returns - String: The name of the config
     */
    fun getName();

    /*
     * Adds a config to the handler
     * Parameter - Config (config): The config to add
     */
    fun addConfig(config);

    /*
     * Gets whether or not the configs will be saved when the script ends
     * Returns - Boolean: Whether or not the configs will be saved when the script ends
     */
    fun willSaveOnClose();

    /*
     * Sets whether or not the configs should be saved when the script ends, by default this is true
     * Parameter - Boolean (saveOnClose): Whether or not the configs should be saved when the script ends
     */
    fun setSaveOnClose(saveOnClose);

    /*
     * Saves the configs to the file
     */
    fun save();

    /*
     * Gets all the configs in the handler
     * Returns - List: All the configs in the handler
     */
    fun getAllConfigs();

    /*
     * Removes a config from the handler
     * Parameter - String (name): The name of the config to remove
     */
    fun removeConfig(name);

    /*
     * Adds multiple configs to the handler
     * Parameter - List (configs): The configs to add
     */
    fun addConfigs(configs);

    /*
     * Gets a config from the handler
     * Parameter - String (name): The name of the config
     * Returns - Config: The config
     */
    fun getConfig(name);
}

/* Native, implemented in Java
 * This class extends Entity and so inherits all of their methods too,
 * LivingEntities are any entities that are alive, so all mobs
 * Import with 'import LivingEntity from Minecraft'
 */
class LivingEntity {
    /*
     * This checks if the LivingEntity is fly falling (gliding with elytra)
     * Returns - Boolean: true if the LivingEntity is fly falling
     */
    fun isFlyFalling();

    /*
     * This gets the LivingEntity's status effects, you can find
     * a list of all the ids of the status effects
     * [here](https://minecraft.fandom.com/wiki/Java_Edition_data_values#Effects)
     * Returns - List: a list of status effects, may be empty
     */
    fun getStatusEffects();

    /*
     * This gets the LivingEntity's current health
     * Returns - Number: the LivingEntity's health
     */
    fun getHealth();
}

/* Native, implemented in Java
 * This class represents a trade offer, and allows you to get information about it.
 * Import with 'import Trade from Minecraft'
 */
class Trade {
    /*
     * Gets the number of times the trade has been used
     * Returns - Number: the number of uses
     */
    fun getUses();

    /*
     * Gets the maximum number of times the trade can be used
     * Returns - Number: the maximum number of uses
     */
    fun getMaxUses();

    /*
     * This gets the special price which is used to adjust the price of the first buy item
     * Returns - Number: the special price
     */
    fun getSpecialPrice();

    /*
     * Gets the second item that the merchant will buy
     * Returns - ItemStack: the second item to buy
     */
    fun getSecondBuyItem();

    /*
     * Gets the price multiplier which is used to adjust the price of the first buy item
     * Returns - Number: the price multiplier
     */
    fun getPriceMultiplier();

    /*
     * Gets the first item that the merchant will buy, adjusted by the price multiplier
     * Returns - ItemStack: the first item to buy
     */
    fun getAdjustedFirstBuyItem();

    /*
     * Gets the item that is being sold by the merchant
     * Returns - ItemStack: the item for sale
     */
    fun getSellItem();

    /*
     * Gets the first item that the merchant will buy
     * Returns - ItemStack: the first item to buy
     */
    fun getFirstBuyItem();
}

/* Native, implemented in Java
 * This allows for many core interactions with the MinecraftClient
 * Import with 'import MinecraftClient from Minecraft'
 */
class MinecraftClient {
    /*
     * This returns the item stack that is currently being held by the cursor
     * Returns - ItemStack: the item stack, will be Air if there is nothing
     */
    fun getCursorStack();

    /*
     * This returns the world that is currently being played on
     * Returns - World: the world
     */
    fun getWorld();

    /*
     * This returns the current player on the client
     * Returns - Player: the main player
     */
    fun getPlayer();

    /*
     * This gets the value of the given client rule
     * Parameter - String (ruleName): the client rule
     * Returns - Value: the value of the client rule
     * Throws - Error: Invalid ClientRule name
     */
    fun getEssentialClientValue(ruleName);

    /*
     * Deprecated: You should use 'new FakeScreen(string, rows)' instead
     * This creates a fake screen with the given name and number of rows of slots available (1 - 6)
     * Parameter - String (screenName): the name of the screen
     * Parameter - Number (rows): number of rows
     * Returns - Value: the fake screen
     */
    fun createFakeScreen(screenName, rows);

    /*
     * Deprecated: You should use 'Entity.of(string)' instead
     * This creates an entity from the given string
     * Parameter - String (string): the string to parse
     * Returns - Value: the entity
     */
    fun entityFromString(string);

    /*
     * This runs the given function on the main thread
     * Parameter - Function (function): the function to run
     */
    fun runOnMainThread(function);

    /*
     * Synchronizes the current thread in Arucas to the next game tick
     * Throws - Error: Tried to sync non Arucas Thread
     */
    fun syncToTick();

    /*
     * This will return the uuid from the given player name
     * Parameter - String (name): the player name
     * Returns - String: the uuid, null if the player name is not found
     */
    fun uuidFromPlayerName(name);

    /*
     * This allows you to register your own client side command in game
     * Parameter - Map (command): a command map or a command builder
     */
    fun addCommand(command);

    /*
     * This allows you to simulate a key release inside of Minecraft, this
     * is useful for keys that only work on release, for example `F3`
     * Parameter - String (key): the key to release
     * Throws - Error: Tried to press unknown key
     */
    fun releaseKey(key);

    /*
     * This makes the client take a screenshot
     */
    fun screenshot();

    /*
     * This makes the client take a screenshot and saves it with a given name
     * Parameter - String (name): the name of the file
     */
    fun screenshot(name);

    /*
     * Deprecated: You should use 'GameEvent.unregisterAll()' instead
     * This unregisters all game events
     */
    fun removeAllGameEvents();

    /*
     * This gets the current connected server's name that you have set it to in the multiplayer screen
     * Returns - String: the server name
     */
    fun getServerName();

    /*
     * This will return the server ip
     * Returns - String: The server ip, null if in single player
     */
    fun getServerIp();

    /*
     * This returns the current render distance set on the client
     * Returns - Number: the render distance
     */
    fun getClientRenderDistance();

    /*
     * This sets the item stack that is currently being held by the cursor, this does not work
     * in normal screens only in FakeScreens, this does not actually pick up an item just display like you have
     * Parameter - ItemStack (itemStack): the item stack to set
     */
    fun setCursorStack(itemStack);

    /*
     * Deprecated: You should use 'Block.of(string)' instead
     * This creates a block from the given string
     * Parameter - String (string): the string to parse
     * Returns - Value: the block
     */
    fun blockFromString(string);

    /*
     * This plays the given sound with the given volume and pitch around the player
     * sound id's can be found [here](https://minecraft.fandom.com/wiki/Sounds.json#Sound_events)
     * Parameter - String (soundId): the sound id you want to play
     * Parameter - Number (volume): the volume of the sound
     * Parameter - Number (pitch): the pitch of the sound
     */
    fun playSound(soundId, volume, pitch);

    /*
     * This sends a script packet to the server
     * You can send the follow types of values:
     * Boolean, Number, String, List (of numbers), Text, ItemStack, Pos, and NbtMaps
     * You can send byte, int, and long arrays by using the strings 'b', 'i', and 'l' at the start of the list
     * Parameter - Value (values...): the data you want to send to the server
     */
    fun sendScriptPacket(values...);

    /*
     * This strips the formatting from the given string
     * Parameter - String (string): the string to strip
     * Returns - String: the stripped string
     */
    fun stripFormatting(string);

    /*
     * This returns the current version of Minecraft you are playing
     * Returns - String: the version for example: '1.17.1'
     */
    fun getVersion();

    /*
     * Deprecated: You should use 'Text.of(string)' instead
     * This creates a text from the given string
     * Parameter - String (string): the string to parse
     * Returns - Value: the text
     */
    fun textFromString(string);

    /*
     * This gets the script directory path, this is where all scripts are stored
     * Returns - String: the script directory path
     */
    fun getScriptsPath();

    /*
     * Returns whether the server supports client script packets
     * Returns - Boolean: Whether the client can send packets to the server
     */
    fun canSendScriptPacket();

    /*
     * This will return the latest chat message
     * Returns - Text: the latest chat message, null if there is none
     */
    fun getLatestChatMessage();

    /*
     * This renders an item in front of the player using the totem of undying animation
     * Parameter - ItemStack (itemStack): the item stack to render
     */
    fun renderFloatingItem(itemStack);

    /*
     * This gets a list of all the mod ids of the mods installed
     * Returns - List: the mod ids
     */
    fun getModList();

    /*
     * This ticks the client
     */
    fun tick();

    /*
     * This gets the current connected server's ping
     * Returns - Number: the server ping in milliseconds
     * Throws - Error: Failed to get server ping
     */
    fun getPing();

    /*
     * This resets the given client rule to its default value
     * Parameter - String (ruleName): the client rule
     * Throws - Error: Invalid ClientRule name
     */
    fun resetEssentialClientRule(ruleName);

    /*
     * Returns the directory where the client is running
     * Returns - File: the Minecraft run directory
     */
    fun getRunDirectory();

    /*
     * Deprecated: You should use 'ItemStack.of(string)' instead
     * This creates an item stack from the given string
     * Parameter - String (string): the string to parse
     * Returns - Value: the item stack
     */
    fun itemFromString(string);

    /*
     * This parses a string and turns it into a Nbt compound
     * Parameter - String (string): the string to parse
     * Returns - Value: the Nbt compound
     */
    fun parseStringToNbt(string);

    /*
     * This allows you to simulate a key press inside of Minecraft, this will only press the key down
     * Parameter - String (key): the key to press
     * Throws - Error: Tried to press key outside of Minecraft
     */
    fun pressKey(key);

    /*
     * This will clear the chat hud
     */
    fun clearChat();

    /*
     * This allows you to simulate a key being held inside of Minecraft, this will press, hold, and release
     * Parameter - String (key): the key to hold
     * Parameter - Number (milliseconds): the number of milliseconds you want it held for
     * Throws - Error: Tried to press unknown key
     */
    fun holdKey(key, milliseconds);

    /*
     * This sets the given client rule to the given value
     * Parameter - String (ruleName): the client rule
     * Parameter - Value (value): the new value for the rule
     * Throws - Error: Invalid ClientRule name, Cannot set that value
     */
    fun setEssentialClientRule(ruleName, value);

    /*
     * This sets the render distance on the client
     * Parameter - Number (number): the render distance
     */
    fun setClientRenderDistance(number);

    /*
     * This will return the player name from the given uuid
     * Parameter - String (uuid): the uuid as a string
     * Returns - String: the player name, null if the uuid is not found
     */
    fun playerNameFromUuid(uuid);

    /*
     * This gets the current fps
     * Returns - Number: the fps
     */
    fun getFps();

    /*
     * This will return true if the client is in single player mode
     * Returns - Boolean: true if the client is in single player mode
     */
    fun isInSinglePlayer();

    /*
     * Returns the MinecraftClient instance
     * Returns - MinecraftClient: the MinecraftClient instance
     */
    static fun get();

    /*
     * Returns the MinecraftClient instance
     * Returns - MinecraftClient: the MinecraftClient instance
     */
    static fun getClient();
}

/* Native, implemented in Java
 * This class allows you to register listeners for game events in Minecraft.
 * Import with 'import GameEvent from Minecraft'
 */
class GameEvent {
    /*
     * This creates a new GameEvent, that is not cancellable
     * Parameter - String (eventName): The name of the event, you can find these on the GameEvents page
     * Parameter - Function (onEvent): The function to run when the event is called, some events may have parameters
     */
    GameEvent(eventName, onEvent);

    /*
     * This creates a new GameEvent
     * Parameter - String (eventName): The name of the event, you can find these on the GameEvents page
     * Parameter - Function (onEvent): The function to run when the event is called, some events may have parameters
     * Parameter - Boolean (cancellable): Whether or not the event is cancellable, if it is then it will run on the main thread
     */
    GameEvent(eventName, onEvent, cancellable);

    /*
     * This unregisters the event
     */
    fun unregister();

    /*
     * This returns whether or not the event is registered
     * Returns - Boolean: Whether or not the event is registered
     */
    fun isRegistered();

    /*
     * This registers the event
     */
    fun register();

    /*
     * If called on a cancellable event, this will stop execution and cancel the event,
     * if called on a non-cancellable event, or not on an event, this will throw an error
     */
    static fun cancel();

    /*
     * This unregisters all events registered by this script
     */
    static fun unregisterAll();
}

/* Native, implemented in Java
 * This class allows you to create a line shape which can be used to draw lines in the world.
 * Import with 'import LineShape from Minecraft'
 */
class LineShape {
    /*
     * Creates a new line shape
     * Parameter - Pos (pos1): The starting position of the line
     * Parameter - Pos (pos2): The ending position of the line
     */
    LineShape(pos1, pos2);

    /*
     * Creates a new line shape
     * Parameter - Number (x1): The x position of the starting position of the line
     * Parameter - Number (y1): The y position of the starting position of the line
     * Parameter - Number (z1): The z position of the starting position of the line
     * Parameter - Number (x2): The x position of the ending position of the line
     * Parameter - Number (y2): The y position of the ending position of the line
     * Parameter - Number (z2): The z position of the ending position of the line
     */
    LineShape(x1, y1, z1, x2, y2, z2);

    /*
     * This sets the colour of the shape, using a single value, this
     * function also has a sibling named `setColor()` that has the same functionality
     * Parameter - Number (colour): the colour, usually you would use hexadecimal, 0xRRGGBB where RR represents red from 00 - FF, GG represents green from 00 - FF, and BB represents blue from 00 - FF
     */
    fun setColour(colour);

    /*
     * This sets the colour of the shape, using three values this function
     * also has a sibling named `setColor()` that has the same functionality
     * Parameter - Number (red): the amount of red 0 - 255
     * Parameter - Number (green): the amount of green 0 - 255
     * Parameter - Number (blue): the amount of blue 0 - 255
     * Throws - Error: Colour ... is out of bounds, must be between 0 - 255
     */
    fun setColour(red, green, blue);

    /*
     * This sets whether the shape should render through blocks
     * Parameter - Boolean (boolean): whether the shape should render through blocks
     */
    fun setRenderThroughBlocks(boolean);

    /*
     * This sets the z scale of the shape
     * Parameter - Number (zScale): the z scale of the shape
     */
    fun setZScale(zScale);

    /*
     * This sets the green value of the shape, using a single value
     * Parameter - Number (green): the amount of green between 0 - 255
     * Throws - Error: Colour ... is out of bounds, must be between 0 - 255
     */
    fun setGreen(green);

    /*
     * This sets the red value of the shape, using a single value
     * Parameter - Number (red): the amount of red between 0 - 255
     * Throws - Error: Colour ... is out of bounds, must be between 0 - 255
     */
    fun setRed(red);

    /*
     * This sets the outline green value of the shape, using a single value
     * Parameter - Number (green): the amount of green between 0 - 255
     */
    fun setOutlineGreen(green);

    /*
     * This gets the y tilt of the shape
     * Returns - Number: the y tilt
     */
    fun getYTilt();

    /*
     * This returns the opacity of the shape
     * Returns - Number: the opacity of the shape
     */
    fun getOpacity();

    /*
     * This sets the first position of the shape
     * Parameter - Pos (pos1): the first position of the shape
     */
    fun setPos1(pos1);

    /*
     * This centers the positions of the shape
     */
    fun centerPositions();

    /*
     * This returns the red value of the shape
     * Returns - Number: the red value of the shape
     */
    fun getRed();

    /*
     * This sets the blue value of the shape, using a single value
     * Parameter - Number (blue): the amount of blue between 0 - 255
     * Throws - Error: Colour ... is out of bounds, must be between 0 - 255
     */
    fun setBlue(blue);

    /*
     * This returns the RGB value of the shape as a list
     * Returns - List: the RGB value of the shape as a list in the form [red, green, blue]
     */
    fun getRGBList();

    /*
     * This sets the outline pixel width of the shape, using a single value
     * Parameter - Number (width): the width of the outline in pixels
     */
    fun setOutlinePixelWidth(width);

    /*
     * This stops the shape from rendering
     */
    fun stopRendering();

    /*
     * This sets the y scale of the shape
     * Parameter - Number (yScale): the y scale of the shape
     */
    fun setYScale(yScale);

    /*
     * This gets the y scale of the shape
     */
    fun getYScale();

    /*
     * This returns the RGBA value of the shape as a list
     * Returns - List: the RGBA value of the shape as a list in the form [red, green, blue, opacity]
     */
    fun getRGBAList();

    /*
     * This gets the z tilt of the shape
     * Returns - Number: the z tilt
     */
    fun getZTilt();

    /*
     * This sets the shape to be rendered indefinitely, the shape will only stop rendering when the script ends or when you call the stopRendering() method
     */
    fun render();

    /*
     * This sets the z tilt of the shape
     * Parameter - Number (zTilt): the z tilt
     */
    fun setZTilt(zTilt);

    /*
     * This returns the RGB value of the shape
     * Returns - Number: the RGB value of the shape as a single number in the form 0xRRGGBB
     */
    fun getRGB();

    /*
     * This gets the z scale of the shape
     */
    fun getZScale();

    /*
     * This sets the x scale of the shape
     * Parameter - Number (xScale): the x scale of the shape
     */
    fun setXScale(xScale);

    /*
     * This sets the scale of the shape
     * Parameter - Number (xScale): the x scale of the shape
     * Parameter - Number (yScale): the y scale of the shape
     * Parameter - Number (zScale): the z scale of the shape
     */
    fun setScale(xScale, yScale, zScale);

    /*
     * This sets the outline red value of the shape, using a single value
     * Parameter - Number (red): the amount of red between 0 - 255
     */
    fun setOutlineRed(red);

    /*
     * This sets the y tilt of the shape
     * Parameter - Number (yTilt): the y tilt
     */
    fun setYTilt(yTilt);

    /*
     * This returns whether the shape should render through blocks
     * Returns - Boolean: whether the shape should render through blocks
     */
    fun shouldRenderThroughBlocks();

    /*
     * This returns the blue value of the shape
     * Returns - Number: the blue value of the shape
     */
    fun getBlue();

    /*
     * This sets the second position of the shape
     * Parameter - Pos (pos2): the second position of the shape
     */
    fun setPos2(pos2);

    /*
     * This sets the tilt of the shape
     * Parameter - Number (xTilt): the x tilt
     * Parameter - Number (yTilt): the y tilt
     * Parameter - Number (zTilt): the z tilt
     */
    fun setTilt(xTilt, yTilt, zTilt);

    /*
     * This returns the green value of the shape
     * Returns - Number: the green value of the shape
     */
    fun getGreen();

    /*
     * This sets the width of the shape, using a single value, this function
     * also has a sibling named `setOutlineColor()` that has the same functionality
     * Parameter - Number (colour): the colour, usually you would use hexadecimal, 0xRRGGBB where RR represents red from 00 - FF, GG represents green from 00 - FF, and BB represents blue from 00 - FF
     */
    fun setOutlineColour(colour);

    /*
     * This sets the outline colour of the shape, using three values, this function
     * also has a sibling named `setOutlineColor()` that has the same functionality
     * Parameter - Number (red): the amount of red 0 - 255
     * Parameter - Number (green): the amount of green 0 - 255
     * Parameter - Number (blue): the amount of blue 0 - 255
     */
    fun setOutlineColour(red, green, blue);

    /*
     * This sets the outline blue value of the shape, using a single value
     * Parameter - Number (blue): the amount of blue between 0 - 255
     */
    fun setOutlineBlue(blue);

    /*
     * This sets the colour of the shape, using a single value, this
     * Parameter - Number (colour): the colour, usually you would use hexadecimal, 0xRRGGBB where RR represents red from 00 - FF, GG represents green from 00 - FF, and BB represents blue from 00 - FF
     */
    fun setColor(colour);

    /*
     * This sets the colour of the shape, using three values this function
     * Parameter - Number (red): the amount of red 0 - 255
     * Parameter - Number (green): the amount of green 0 - 255
     * Parameter - Number (blue): the amount of blue 0 - 255
     * Throws - Error: Colour ... is out of bounds, must be between 0 - 255
     */
    fun setColor(red, green, blue);

    /*
     * This gets the x scale of the shape
     */
    fun getXScale();

    /*
     * This sets the width of the shape, using a single value, this function
     * Parameter - Number (colour): the colour, usually you would use hexadecimal, 0xRRGGBB where RR represents red from 00 - FF, GG represents green from 00 - FF, and BB represents blue from 00 - FF
     */
    fun setOutlineColor(colour);

    /*
     * This sets the outline colour of the shape, using three values, this function
     * Parameter - Number (red): the amount of red 0 - 255
     * Parameter - Number (green): the amount of green 0 - 255
     * Parameter - Number (blue): the amount of blue 0 - 255
     */
    fun setOutlineColor(red, green, blue);

    /*
     * This sets the x tilt of the shape
     * Parameter - Number (xTilt): the x tilt
     */
    fun setXTilt(xTilt);

    /*
     * This gets the x tilt of the shape
     * Returns - Number: the x tilt
     */
    fun getXTilt();

    /*
     * This sets the opacity of the shape, using a single value
     * Parameter - Number (alpha): the opacity, where 255 is solid colour and 0 is no colour
     * Throws - Error: Colour ... is out of bounds, must be between 0 - 255
     */
    fun setOpacity(alpha);
}

/* Native, implemented in Java
 * This class is used to represent all players, mainly other players,
 * this class extends LivingEntity and so inherits all of their methods too
 * Import with 'import OtherPlayer from Minecraft'
 */
class OtherPlayer {
    /*
     * This gets all the slot numbers of the specified item in the players combined inventory
     * Parameter - MaterialLike (materialLike): the item or material you want to get the slot of
     * Returns - List: the slot numbers of the item, empty list if not found
     */
    fun getAllSlotsFor(materialLike);

    /*
     * This gets the slot number of the specified item in the players combined inventory
     * Parameter - MaterialLike (materialLike): the item or material you want to get the slot of
     * Returns - Number: the slot number of the item, null if not found
     */
    fun getSlotFor(materialLike);

    /*
     * This gets the players currently selected item, in their main hand
     * Returns - ItemStack: the currently selected item
     */
    fun getHeldItem();

    /*
     * This gets the item in the specified slot, in the total players inventory, including inventories of open containers
     * Parameter - Number (slotNum): the slot number you want to get
     * Returns - ItemStack: the item in the specified slot
     * Throws - Error: That slot is out of bounds
     */
    fun getItemForSlot(slotNum);

    /*
     * This gets the players currently selected slot
     * Returns - Number: the currently selected slot number
     */
    fun getCurrentSlot();

    /*
     * This gets the saturation level of the player
     * Returns - Number: the saturation level
     */
    fun getSaturation();

    /*
     * This gets the players name
     * Returns - String: the players name
     */
    fun getPlayerName();

    /*
     * This gets the fishing bobber that the player has
     * Returns - Entity: the fishing bobber entity, null if the player isn't fishing
     */
    fun getFishingBobber();

    /*
     * This gets the number of experience levels the player has
     * Returns - Number: the number of experience levels
     */
    fun getLevels();

    /*
     * This gets whether the players inventory is full
     * Returns - Boolean: whether the inventory is full
     */
    fun isInventoryFull();

    /*
     * This gets the players total inventory slots
     * Returns - Number: the players total inventory slots
     */
    fun getTotalSlots();

    /*
     * This gets the abilities of the player in a map
     * For example:
     * `{"invulnerable": false, "canFly": true, "canBreakBlocks": true, "isCreative": true, "walkSpeed": 1.0, "flySpeed": 1.2}`
     * Returns - Map: the abilities of the player
     */
    fun getAbilities();

    /*
     * This gets the item in the specified slot, in the players inventory, not including inventories of open containers
     * Parameter - Number (slotNum): the slot number you want to get
     * Returns - ItemStack: the item in the specified slot
     * Throws - Error: That slot is out of bounds
     */
    fun getItemForPlayerSlot(slotNum);

    /*
     * This gets the players gamemode
     * Returns - String: the players gamemode as a string, null if not known, for example 'creative', 'survival', 'spectator'
     */
    fun getGamemode();

    /*
     * This gets the hunger level of the player
     * Returns - Number: the hunger level
     */
    fun getHunger();
}

/* Native, implemented in Java
 * This class allows you to create box shapes that can be rendered in the world.
 * Import with 'import BoxShape from Minecraft'
 */
class BoxShape {
    /*
     * Creates a new box shape, this is used to render boxes
     * Parameter - Pos (pos): The position which will be used for the first and second corner of the box
     */
    BoxShape(pos);

    /*
     * Creates a new box shape, this is used to render boxes
     * Parameter - Pos (pos1): The position of the first corner of the box
     * Parameter - Pos (pos2): The position of the second corner of the box
     */
    BoxShape(pos1, pos2);

    /*
     * Creates a new box shape, this is used to render boxes
     * Parameter - Number (x): The x position which will be used for the first and second corner of the box
     * Parameter - Number (y): The y position which will be used for the first and second corner of the box
     * Parameter - Number (z): The z position which will be used for the first and second corner of the box
     */
    BoxShape(x, y, z);

    /*
     * Creates a new box shape, this is used to render boxes
     * Parameter - Number (x1): The x position of the first corner of the box
     * Parameter - Number (y1): The y position of the first corner of the box
     * Parameter - Number (z1): The z position of the first corner of the box
     * Parameter - Number (x2): The x position of the second corner of the box
     * Parameter - Number (y2): The y position of the second corner of the box
     * Parameter - Number (z2): The z position of the second corner of the box
     */
    BoxShape(x1, y1, z1, x2, y2, z2);

    /*
     * This sets the colour of the shape, using a single value, this
     * function also has a sibling named `setColor()` that has the same functionality
     * Parameter - Number (colour): the colour, usually you would use hexadecimal, 0xRRGGBB where RR represents red from 00 - FF, GG represents green from 00 - FF, and BB represents blue from 00 - FF
     */
    fun setColour(colour);

    /*
     * This sets the colour of the shape, using three values this function
     * also has a sibling named `setColor()` that has the same functionality
     * Parameter - Number (red): the amount of red 0 - 255
     * Parameter - Number (green): the amount of green 0 - 255
     * Parameter - Number (blue): the amount of blue 0 - 255
     * Throws - Error: Colour ... is out of bounds, must be between 0 - 255
     */
    fun setColour(red, green, blue);

    /*
     * This sets whether the shape should render through blocks
     * Parameter - Boolean (boolean): whether the shape should render through blocks
     */
    fun setRenderThroughBlocks(boolean);

    /*
     * This sets the z scale of the shape
     * Parameter - Number (zScale): the z scale of the shape
     */
    fun setZScale(zScale);

    /*
     * This sets the green value of the shape, using a single value
     * Parameter - Number (green): the amount of green between 0 - 255
     * Throws - Error: Colour ... is out of bounds, must be between 0 - 255
     */
    fun setGreen(green);

    /*
     * This sets the red value of the shape, using a single value
     * Parameter - Number (red): the amount of red between 0 - 255
     * Throws - Error: Colour ... is out of bounds, must be between 0 - 255
     */
    fun setRed(red);

    /*
     * This sets the outline green value of the shape, using a single value
     * Parameter - Number (green): the amount of green between 0 - 255
     */
    fun setOutlineGreen(green);

    /*
     * This gets the y tilt of the shape
     * Returns - Number: the y tilt
     */
    fun getYTilt();

    /*
     * This returns the opacity of the shape
     * Returns - Number: the opacity of the shape
     */
    fun getOpacity();

    /*
     * This sets the first position of the shape
     * Parameter - Pos (pos1): the first position of the shape
     */
    fun setPos1(pos1);

    /*
     * This centers the positions of the shape
     */
    fun centerPositions();

    /*
     * This returns the red value of the shape
     * Returns - Number: the red value of the shape
     */
    fun getRed();

    /*
     * This sets the blue value of the shape, using a single value
     * Parameter - Number (blue): the amount of blue between 0 - 255
     * Throws - Error: Colour ... is out of bounds, must be between 0 - 255
     */
    fun setBlue(blue);

    /*
     * This returns the RGB value of the shape as a list
     * Returns - List: the RGB value of the shape as a list in the form [red, green, blue]
     */
    fun getRGBList();

    /*
     * This sets the outline pixel width of the shape, using a single value
     * Parameter - Number (width): the width of the outline in pixels
     */
    fun setOutlinePixelWidth(width);

    /*
     * This stops the shape from rendering
     */
    fun stopRendering();

    /*
     * This sets the y scale of the shape
     * Parameter - Number (yScale): the y scale of the shape
     */
    fun setYScale(yScale);

    /*
     * This gets the y scale of the shape
     */
    fun getYScale();

    /*
     * This returns the RGBA value of the shape as a list
     * Returns - List: the RGBA value of the shape as a list in the form [red, green, blue, opacity]
     */
    fun getRGBAList();

    /*
     * This gets the z tilt of the shape
     * Returns - Number: the z tilt
     */
    fun getZTilt();

    /*
     * This sets the shape to be rendered indefinitely, the shape will only stop rendering when the script ends or when you call the stopRendering() method
     */
    fun render();

    /*
     * This sets the z tilt of the shape
     * Parameter - Number (zTilt): the z tilt
     */
    fun setZTilt(zTilt);

    /*
     * This returns the RGB value of the shape
     * Returns - Number: the RGB value of the shape as a single number in the form 0xRRGGBB
     */
    fun getRGB();

    /*
     * This gets the z scale of the shape
     */
    fun getZScale();

    /*
     * This sets the x scale of the shape
     * Parameter - Number (xScale): the x scale of the shape
     */
    fun setXScale(xScale);

    /*
     * This sets the scale of the shape
     * Parameter - Number (xScale): the x scale of the shape
     * Parameter - Number (yScale): the y scale of the shape
     * Parameter - Number (zScale): the z scale of the shape
     */
    fun setScale(xScale, yScale, zScale);

    /*
     * This sets the outline red value of the shape, using a single value
     * Parameter - Number (red): the amount of red between 0 - 255
     */
    fun setOutlineRed(red);

    /*
     * This sets the y tilt of the shape
     * Parameter - Number (yTilt): the y tilt
     */
    fun setYTilt(yTilt);

    /*
     * This returns whether the shape should render through blocks
     * Returns - Boolean: whether the shape should render through blocks
     */
    fun shouldRenderThroughBlocks();

    /*
     * This returns the blue value of the shape
     * Returns - Number: the blue value of the shape
     */
    fun getBlue();

    /*
     * This sets the second position of the shape
     * Parameter - Pos (pos2): the second position of the shape
     */
    fun setPos2(pos2);

    /*
     * This sets the tilt of the shape
     * Parameter - Number (xTilt): the x tilt
     * Parameter - Number (yTilt): the y tilt
     * Parameter - Number (zTilt): the z tilt
     */
    fun setTilt(xTilt, yTilt, zTilt);

    /*
     * This returns the green value of the shape
     * Returns - Number: the green value of the shape
     */
    fun getGreen();

    /*
     * This sets the width of the shape, using a single value, this function
     * also has a sibling named `setOutlineColor()` that has the same functionality
     * Parameter - Number (colour): the colour, usually you would use hexadecimal, 0xRRGGBB where RR represents red from 00 - FF, GG represents green from 00 - FF, and BB represents blue from 00 - FF
     */
    fun setOutlineColour(colour);

    /*
     * This sets the outline colour of the shape, using three values, this function
     * also has a sibling named `setOutlineColor()` that has the same functionality
     * Parameter - Number (red): the amount of red 0 - 255
     * Parameter - Number (green): the amount of green 0 - 255
     * Parameter - Number (blue): the amount of blue 0 - 255
     */
    fun setOutlineColour(red, green, blue);

    /*
     * This sets the outline blue value of the shape, using a single value
     * Parameter - Number (blue): the amount of blue between 0 - 255
     */
    fun setOutlineBlue(blue);

    /*
     * This sets the colour of the shape, using a single value, this
     * Parameter - Number (colour): the colour, usually you would use hexadecimal, 0xRRGGBB where RR represents red from 00 - FF, GG represents green from 00 - FF, and BB represents blue from 00 - FF
     */
    fun setColor(colour);

    /*
     * This sets the colour of the shape, using three values this function
     * Parameter - Number (red): the amount of red 0 - 255
     * Parameter - Number (green): the amount of green 0 - 255
     * Parameter - Number (blue): the amount of blue 0 - 255
     * Throws - Error: Colour ... is out of bounds, must be between 0 - 255
     */
    fun setColor(red, green, blue);

    /*
     * This gets the x scale of the shape
     */
    fun getXScale();

    /*
     * This sets the width of the shape, using a single value, this function
     * Parameter - Number (colour): the colour, usually you would use hexadecimal, 0xRRGGBB where RR represents red from 00 - FF, GG represents green from 00 - FF, and BB represents blue from 00 - FF
     */
    fun setOutlineColor(colour);

    /*
     * This sets the outline colour of the shape, using three values, this function
     * Parameter - Number (red): the amount of red 0 - 255
     * Parameter - Number (green): the amount of green 0 - 255
     * Parameter - Number (blue): the amount of blue 0 - 255
     */
    fun setOutlineColor(red, green, blue);

    /*
     * This sets the x tilt of the shape
     * Parameter - Number (xTilt): the x tilt
     */
    fun setXTilt(xTilt);

    /*
     * This gets the x tilt of the shape
     * Returns - Number: the x tilt
     */
    fun getXTilt();

    /*
     * This sets the opacity of the shape, using a single value
     * Parameter - Number (alpha): the opacity, where 255 is solid colour and 0 is no colour
     * Throws - Error: Colour ... is out of bounds, must be between 0 - 255
     */
    fun setOpacity(alpha);
}

/* Native, implemented in Java
 * This class is used to interact with the main player, this extends OtherPlayer
 * and so inherits all methods from that class.
 * Import with 'import Player from Minecraft'
 */
class Player {
    /*
     * This opens a screen for the player, this cannot open server side screens
     * Parameter - Screen (screen): the screen to open
     * Throws - Error: Opening handled screens is unsafe
     */
    fun openScreen(screen);

    /*
     * This will get the next empty slot in the hotbar starting from the current slot
     * going right, and if it reaches the end of the hotbar it will start from the beginning.
     * If there is no empty slot it will return any slot that doesn't have an item with
     * an enchantment that is in the hotbar, again going from the current slot
     * if there is no such slot it will return the current selected slot
     * Returns - Number: the slot that is swappable
     */
    fun getSwappableHotbarSlot();

    /*
     * This allows you to name an item in an anvil
     * Parameter - String (name): the name you want to give the item
     * Parameter - Function (predicate): whether the ItemStack meets a certain criteria
     * Returns - Boolean: whether the anvilling was successful, if the player doesn't have enough levels it will return the xp cost
     * Throws - Error: Not in anvil gui, Invalid function parameter
     */
    fun anvilRename(name, predicate);

    /*
     * This allows you to combine two items in an anvil
     * Parameter - Function (predicate1): a function determining whether the first ItemStack meets a criteria
     * Parameter - Function (predicate2): a function determining whether the second ItemStack meets a criteria
     * Returns - Boolean: whether the anvilling was successful, if the player doesn't have enough levels it will return the xp cost
     * Throws - Error: Not in anvil gui, Invalid function parameter
     */
    fun anvil(predicate1, predicate2);

    /*
     * This allows you to make your player use
     * Parameter - String (action): the type of action, either 'hold', 'stop', or 'once'
     * Throws - Error: Must pass 'hold', 'stop', or 'once' into use()
     */
    fun use(action);

    /*
     * This allows you to craft a predefined recipe
     * Parameter - Recipe (recipe): the recipe you want to craft
     * Throws - Error: Must be in a crafting GUI
     */
    fun craftRecipe(recipe);

    /*
     * This allows you to craft a recipe, this can be 2x2 or 3x3
     * The list you pass in must contain Materials or ItemStacks
     * Most of the time you should use craftRecipe instead
     * Parameter - List (recipe): a list of materials making up the recipe you want to craft including air
     * Throws - Error: Must be in a crafting GUI, You must be in a crafting table to craft a 3x3, Recipe must either be 3x3 or 2x2, The recipe must only include items or materials
     */
    fun craft(recipe);

    /*
     * This allows your player to interact with an entity without
     * having to be looking at it or clicking on the entity
     * Parameter - Entity (entity): the entity to interact with
     */
    fun interactWithEntity(entity);

    /*
     * This allows you to set the current memssage displaying on the action bar
     * Parameter - Text (message): the message to send, can also be string
     */
    fun messageActionBar(message);

    /*
     * This gets the entity that the player is currently looking at
     * Returns - Entity: the entity that the player is looking at
     */
    fun getLookingAtEntity();

    /*
     * This allows you to attack a block at a position and direction
     * Parameter - Pos (pos): the position of the block
     * Parameter - String (direction): the direction of the attack, e.g. 'up', 'north', 'east', etc.
     */
    fun attackBlock(pos, direction);

    /*
     * This allows you to attack a block at a position and direction
     * Parameter - Number (x): the x position
     * Parameter - Number (y): the y position
     * Parameter - Number (z): the z position
     * Parameter - String (direction): the direction of the attack, e.g. 'up', 'north', 'east', etc.
     */
    fun attackBlock(x, y, z, direction);

    /*
     * This forces the player to leave the world
     * Parameter - String (message): the message to display to the player on the logout screen
     */
    fun logout(message);

    /*
     * This drops the item(s) in the player's main hand
     * Parameter - Boolean (dropAll): if true, all items in the player's main hand will be dropped
     */
    fun dropItemInHand(dropAll);

    /*
     * This allows you to set the slot number your player is holding
     * Parameter - Number (slot): the slot number, must be between 0 - 8
     * Throws - Error: Number must be between 0 - 8
     */
    fun setSelectedSlot(slot);

    fun getPriceForIndex(arg1);

    /*
     * This allows you to make your player attack
     * Parameter - String (action): the type of action, either 'hold', 'stop', or 'once'
     * Throws - Error: Must pass 'hold', 'stop', or 'once' into attack()
     */
    fun attack(action);

    /*
     * This will play the player's hand swing animation for a given hand
     * Parameter - String (hand): the hand to swing, this should be either 'main_hand' or 'off_hand'
     */
    fun swingHand(hand);

    /*
     * This allows you to use the stonecutter
     * Parameter - MaterialLike (itemInput): the item or material you want to input
     * Parameter - MaterialLike (itemOutput): the item or material you want to craft
     * Returns - Boolean: whether the result was successful
     * Throws - Error: Not in stonecutter gui, Recipe does not exist
     */
    fun stonecutter(itemInput, itemOutput);

    /*
     * This sets the player's sneaking state
     * Parameter - Boolean (sneaking): the sneaking state
     */
    fun setSneaking(sneaking);

    /*
     * This sets the player's walking state
     * Parameter - Boolean (walking): the walking state
     */
    fun setWalking(walking);

    /*
     * This breaks a block at a given position, if it is able to be broken
     * Parameter - Pos (pos): the position of the block
     * Returns - Boolean: whether the block can be broken
     */
    fun breakBlock(pos);

    /*
     * This breaks a block at a given position, if it is able to be broken
     * and runs a function when the block is broken, or when the block cannot be broken
     * Parameter - Pos (pos): the position of the block
     * Parameter - Function (function): the function to run when the block is broken
     * Returns - Boolean: whether the block can be broken
     */
    fun breakBlock(pos, function);

    fun doesVillagerHaveTrade(arg1);

    fun tradeIndex(arg1);

    /*
     * This will make the player jump if they are on the ground
     */
    fun jump();

    /*
     * This opens the player's inventory
     */
    fun openInventory();

    /*
     * This allows you to swap a slot in the player's inventory with the hotbar
     * Parameter - Number (slot): the slot to swap
     * Throws - Error: That slot is out of bounds
     */
    fun swapPlayerSlotWithHotbar(slot);

    fun isTradeDisabled(arg1);

    /*
     * This allows you to teleport to any entity as long as you are in spectator mode
     * Parameter - Entity (entity): the entity to teleport to
     */
    fun spectatorTeleport(entity);

    /*
     * This returns the block breaking speed of the player on a block including enchanements and effects
     * Parameter - Block (block): the block to get the speed of
     */
    fun getBlockBreakingSpeed(block);

    /*
     * This closes the current screen
     */
    fun closeScreen();

    /*
     * This gets the current screen the player is in
     * Returns - Screen: the screen the player is in, if the player is not in a screen it will return null
     */
    fun getCurrentScreen();

    /*
     * This allows you to update your block breaking progress at a position
     * Parameter - Pos (pos): the position of the block
     */
    fun updateBreakingBlock(pos);

    /*
     * This allows you to update your block breaking progress at a position
     * Parameter - Number (x): the x position
     * Parameter - Number (y): the y position
     * Parameter - Number (z): the z position
     */
    fun updateBreakingBlock(x, y, z);

    /*
     * This makes the player 'fake' looking in a direction, this can be
     * used to place blocks in unusual orientations without moving the camera
     * Parameter - Number (yaw): the yaw to look at
     * Parameter - Number (pitch): the pitch to look at
     * Parameter - String (direction): the direction to look at
     * Parameter - Number (duration): the duration of the look in ticks
     */
    fun fakeLook(yaw, pitch, direction, duration);

    /*
     * This allows you to make your player send a message in chat, this includes commands
     * Parameter - String (message): the message to send
     */
    fun say(message);

    /*
     * The allows you to swap two slots with one another
     * A note about slot order is that slots go from top to bottom
     * Parameter - Number (slot1): the slot to swap with slot2
     * Parameter - Number (slot2): the slot to swap with slot1
     * Throws - Error: That slot is out of bounds
     */
    fun swapSlots(slot1, slot2);

    fun getTradeItemForIndex(arg1);

    /*
     * This allows you to send a message to your player, only they will see this, purely client side
     * Parameter - Text (message): the message to send, can also be string
     */
    fun message(message);

    /*
     * This sets the player's look direction
     * Parameter - Number (yaw): the yaw of the player's look direction
     * Parameter - Number (pitch): the pitch of the player's look direction
     */
    fun look(yaw, pitch);

    /*
     * This allows you to shift click a slot
     * Parameter - Number (slot): the slot to click
     * Throws - Error: That slot is out of bounds
     */
    fun shiftClickSlot(slot);

    fun getIndexOfTradeItem(arg1);

    /*
     * This drops all items of a given type in the player's inventory
     * Parameter - MaterialLike (materialLike): the item stack, or material type to drop
     */
    fun dropAll(materialLike);

    fun showTitle(arg1);

    /*
     * This makes your player look towards a position
     * Parameter - Pos (pos): the position to look at
     */
    fun lookAtPos(pos);

    /*
     * This makes your player look towards a position
     * Parameter - Number (x): the x coordinate of the position
     * Parameter - Number (y): the y coordinate of the position
     * Parameter - Number (z): the z coordinate of the position
     */
    fun lookAtPos(x, y, z);

    /*
     * This will swap the player's main hand with the off hand
     */
    fun swapHands();

    /*
     * This allows you to click a slot with either right or left click
     * and a slot action, the click must be either 'left' or 'right' or a number (for swap).
     * The action must be either 'click', 'shift_click', 'swap', 'middle_click',
     * 'throw', 'drag', or 'double_click'
     * Parameter - Number (slot): the slot to click
     * Parameter - String (click): the click type, this should be either 'left' or 'right'
     * Parameter - String (action): the action to perform
     * Throws - Error: Invalid clickData must be 'left' or 'right' or a number, Invalid slotActionType, see Wiki, That slot is out of bounds
     */
    fun clickSlot(slot, click, action);

    /*
     * This allows you to drop the items in a slot
     * Parameter - Number (slot): the slot to drop
     * Throws - Error: That slot is out of bounds
     */
    fun dropSlot(slot);

    /*
     * This makes your player attack an entity without
     * having to be looking at it or clicking on the entity
     * Parameter - Entity (entity): the entity to attack
     */
    fun attackEntity(entity);

    /*
     * This sets the player's sprinting state
     * Parameter - Boolean (sprinting): the sprinting state
     */
    fun setSprinting(sprinting);

    /*
     * This allows you to interact with a block at a position and direction
     * Parameter - Pos (pos): the position of the block
     * Parameter - String (direction): the direction of the interaction, e.g. 'up', 'north', 'east', etc.
     */
    fun interactBlock(pos, direction);

    /*
     * This allows you to interact with a block at a position and direction
     * This function is for very specific cases where there needs to be extra precision
     * like when placing stairs or slabs in certain directions, so the first set of
     * coords is the exact position of the block, and the second set of coords is the position
     * Parameter - Pos (pos): the exact position of the block
     * Parameter - String (direction): the direction of the interaction, e.g. 'up', 'north', 'east', etc.
     * Parameter - Pos (blockPos): the position of the block
     * Parameter - Boolean (insideBlock): whether the player is inside the block
     */
    fun interactBlock(pos, direction, blockPos, insideBlock);

    /*
     * This allows you to interact with a block at a position and direction
     * This function is for very specific cases where there needs to be extra precision
     * like when placing stairs or slabs in certain directions, so the first set of
     * coords is the exact position of the block, and the second set of coords is the position
     * Parameter - Number (x): the exact x position
     * Parameter - Number (y): the exact y position
     * Parameter - Number (z): the exact z position
     * Parameter - String (direction): the direction of the interaction, e.g. 'up', 'north', 'east', etc.
     * Parameter - Number (blockX): the x position of the block
     * Parameter - Number (blockY): the y position of the block
     * Parameter - Number (blockZ): the z position of the block
     * Parameter - Boolean (insideBlock): whether the player is inside the block
     */
    fun interactBlock(x, y, z, direction, blockX, blockY, blockZ, insideBlock);

    /*
     * This gets the main player
     * Returns - Player: The main player
     */
    static fun get();
}

/* Native, implemented in Java
 * This class extends Entity and so inherits all of their methods too,
 * ItemEntities are entities that are dropped items.
 * Import with 'import ItemEntity from Minecraft'
 */
class ItemEntity {
    /*
     * This method returns the custom name of the ItemEntity
     * Returns - String: the custom name of the entity
     */
    fun getCustomName();

    /*
     * This method returns the age of the ItemEntity
     * this is increased every tick and the item entity despawns after 6000 ticks
     * Returns - Number: the age of the entity
     */
    fun getItemAge();

    /*
     * This method returns the ItemStack that is held in the ItemEntity
     * Returns - ItemStack: the ItemStack that the entity holds
     */
    fun getItemStack();

    /*
     * This method returns the player that threw the ItemEntity
     */
    fun getThrower();
}

/* Native, implemented in Java
 * This class extends Screen and so inherits all of their methods too,
 * this class is used to add functionality to trading screens.
 * Import with 'import MerchantScreen from Minecraft'
 */
class MerchantScreen {
    /*
     * This clears the currently selected trade
     * Throws - Error: Not in merchant gui
     */
    fun clearTrade();

    /*
     * This returns true if a trade is selected
     * Returns - Boolean: true if a trade is selected
     */
    fun isTradeSelected();

    /*
     * This returns true if a trade is disabled at an index
     * Parameter - Number (index): the index of the trade
     * Returns - Boolean: true if a trade is disabled
     */
    fun isTradeDisabled(index);

    /*
     * This gets the profession of the villager
     * Returns - String: the profession of the villager, for example: 'armorer', 'mason', 'weaponsmith'
     * Throws - Error: Merchant isn't a villager
     */
    fun getVillagerProfession();

    /*
     * This gets a list of all the merchant's trades
     * Returns - List: the list of all the Trades
     */
    fun getTradeList();

    /*
     * This trades the currently selected trade and throws the items that were traded
     * Throws - Error: Not in merchant gui
     */
    fun tradeSelectedAndThrow();

    /*
     * This gets the item stack of a trade at a certain index
     * Parameter - Number (index): the index of the trade
     * Returns - ItemStack: the item stack of the trade
     * Throws - Error: Not in merchant gui, That trade is out of bounds
     */
    fun getTradeItemForIndex(index);

    /*
     * This trades the currently selected trade
     * Throws - Error: Not in merchant gui
     */
    fun tradeSelected();

    /*
     * This gets the size of all the trades available
     * Returns - Number: the size of the trade list
     */
    fun getTradeListSize();

    /*
     * This selects the currently selected trade, as if you were to click it
     * Parameter - Number (index): the index of the trade
     * Throws - Error: Not in merchant gui
     */
    fun selectTrade(index);

    /*
     * This gets the price of a trade at a certain index
     * Parameter - Number (index): the index of the trade
     * Returns - Number: the price of the trade
     * Throws - Error: Not in merchant gui, That trade is out of bounds
     */
    fun getPriceForIndex(index);

    /*
     * This gets the level of the villager
     * Returns - Number: the level of the villager
     * Throws - Error: Merchant isn't a villager
     */
    fun getVillagerLevel();

    /*
     * This gets the index of a trade for a certain item
     * Parameter - MaterialLike (materialLike): the item to get the index of
     * Returns - Number: the index of the trade
     * Throws - Error: Not in merchant gui
     */
    fun getIndexOfTradeItem(materialLike);

    /*
     * This checks if the villager has a trade for a certain item
     * Parameter - MaterialLike (materialLike): the item or material to check for
     * Returns - Boolean: true if the villager has a trade for the item, false otherwise
     * Throws - Error: Not in merchant gui, That trade is out of bounds
     */
    fun doesVillagerHaveTrade(materialLike);

    /*
     * This makes your player trade with the merchant at a certain index
     * Parameter - Number (index): the index of the trade
     * Throws - Error: Not in merchant gui
     */
    fun tradeIndex(index);
}

/* Native, implemented in Java
 * This class can be used to create fake blocks which can be rendered in the world.
 * Import with 'import FakeBlock from Minecraft'
 */
class FakeBlock {
    /*
     * Creates a fake block with the given block and position
     * Parameter - Block (block): The block to use
     * Parameter - Pos (pos): The position of the block
     */
    FakeBlock(block, pos);

    /*
     * This gets the z scale of the shape
     */
    fun getZScale();

    /*
     * Gets the current block type of the fake block
     * Returns - Block: The block type of the fake block
     */
    fun getBlock();

    /*
     * This gets the direction of the shape
     * Returns - String: the direction of the shape as a string, this can be 'north', 'south', 'east', 'west', 'down', or 'up', null if it has no direction
     */
    fun getDirection();

    /*
     * This sets the x scale of the shape
     * Parameter - Number (xScale): the x scale of the shape
     */
    fun setXScale(xScale);

    /*
     * This sets the scale of the shape
     * Parameter - Number (xScale): the x scale of the shape
     * Parameter - Number (yScale): the y scale of the shape
     * Parameter - Number (zScale): the z scale of the shape
     */
    fun setScale(xScale, yScale, zScale);

    /*
     * This sets the y tilt of the shape
     * Parameter - Number (yTilt): the y tilt
     */
    fun setYTilt(yTilt);

    /*
     * Sets the block type to render of the fake block
     * Parameter - Block (block): The block to render
     */
    fun setBlock(block);

    /*
     * This sets the z scale of the shape
     * Parameter - Number (zScale): the z scale of the shape
     */
    fun setZScale(zScale);

    /*
     * This gets the y tilt of the shape
     * Returns - Number: the y tilt
     */
    fun getYTilt();

    /*
     * This sets the tilt of the shape
     * Parameter - Number (xTilt): the x tilt
     * Parameter - Number (yTilt): the y tilt
     * Parameter - Number (zTilt): the z tilt
     */
    fun setTilt(xTilt, yTilt, zTilt);

    /*
     * Sets the position of the fake block
     * Parameter - Pos (pos): The position of the block
     */
    fun setPos(pos);

    /*
     * This gets the x scale of the shape
     */
    fun getXScale();

    /*
     * This stops the shape from rendering
     */
    fun stopRendering();

    /*
     * This sets the y scale of the shape
     * Parameter - Number (yScale): the y scale of the shape
     */
    fun setYScale(yScale);

    /*
     * This gets the y scale of the shape
     */
    fun getYScale();

    /*
     * Gets the current position of the fake block
     * Returns - Pos: The position of the fake block
     */
    fun getPos();

    /*
     * This sets the direction of the shape
     * Parameter - String (direction): the direction of the shape as a string, this can be 'north', 'south', 'east', 'west', 'down', or 'up'
     */
    fun setDirection(direction);

    /*
     * This sets the x tilt of the shape
     * Parameter - Number (xTilt): the x tilt
     */
    fun setXTilt(xTilt);

    /*
     * This gets the z tilt of the shape
     * Returns - Number: the z tilt
     */
    fun getZTilt();

    /*
     * This sets the shape to be rendered indefinitely, the shape will only stop rendering when the script ends or when you call the stopRendering() method
     */
    fun render();

    /*
     * This sets the z tilt of the shape
     * Parameter - Number (zTilt): the z tilt
     */
    fun setZTilt(zTilt);

    /*
     * This gets the x tilt of the shape
     * Returns - Number: the x tilt
     */
    fun getXTilt();
}

/* Native, implemented in Java
 * This class is used to create formatted strings used inside Minecraft.
 * Import with 'import Text from Minecraft'
 */
class Text {
    /*
     * This allows you to add a formatting to a text instance
     * A list of formatting names can be found [here](https://minecraft.fandom.com/wiki/Formatting_codes)
     * Parameter - String (formatting): the name of the formatting
     * Returns - Text: the text instance with the formatting added
     * Throws - Error: Invalid formatting: ...
     */
    fun format(formatting);

    /*
     * This allows you to add a hover event to a text instance
     * The possible events are: 'show_text', 'show_item', 'show_entity'
     * Parameter - String (event): the name of the event
     * Parameter - Value (value): the value associated with the event
     * Returns - Text: the text instance with the hover event
     * Throws - Error: Invalid action: ...
     */
    fun withHoverEvent(event, value);

    /*
     * This allows you to add a click event to a text instance
     * The possible events are: 'open_url', 'open_file', 'run_command', 'suggest_command', 'copy_to_clipboard', 'run_function'
     * Parameter - String (event): the name of the event
     * Parameter - String (value): the value associated with the event
     * Returns - Text: the text instance with the click event
     * Throws - Error: Invalid action: ...
     */
    fun withClickEvent(event, value);

    /*
     * This allows you to append a text instance to another text instance
     * Parameter - Text (otherText): the text instance to append to
     * Returns - Text: the text instance with the appended text
     */
    fun append(otherText);

    /*
     * This converts a string into a text instance
     * Parameter - String (string): The string to convert into a text instance
     * Returns - Text: the text instance from the string
     */
    static fun of(string);

    /*
     * This converts a text json into a text instance
     * Parameter - String (textJson): The string in json format, or a Json value itself
     * Returns - Text: the text instance from the json
     */
    static fun parse(textJson);
}

/* Native, implemented in Java
 * This class represents all possible item and block types
 * and allows you to convert them into instances of ItemStacks and Blocks
 * Import with 'import Material from Minecraft'
 */
class Material {
    /*
     * This is a list of all materials in the game, including items and blocks, each material also has it's own member
     * The type of the field is Material
     * This field is not assignable
     */
    static var ALL;
    static var ACACIA_BOAT;
    static var ACACIA_BUTTON;
    static var ACACIA_CHEST_BOAT;
    static var ACACIA_DOOR;
    static var ACACIA_FENCE;
    static var ACACIA_FENCE_GATE;
    static var ACACIA_LEAVES;
    static var ACACIA_LOG;
    static var ACACIA_PLANKS;
    static var ACACIA_PRESSURE_PLATE;
    static var ACACIA_SAPLING;
    static var ACACIA_SIGN;
    static var ACACIA_SLAB;
    static var ACACIA_STAIRS;
    static var ACACIA_TRAPDOOR;
    static var ACACIA_WALL_SIGN;
    static var ACACIA_WOOD;
    static var ACTIVATOR_RAIL;
    static var AIR;
    static var ALLAY_SPAWN_EGG;
    static var ALLIUM;
    static var AMETHYST_BLOCK;
    static var AMETHYST_CLUSTER;
    static var AMETHYST_SHARD;
    static var ANCIENT_DEBRIS;
    static var ANDESITE;
    static var ANDESITE_SLAB;
    static var ANDESITE_STAIRS;
    static var ANDESITE_WALL;
    static var ANVIL;
    static var APPLE;
    static var ARMOR_STAND;
    static var ARROW;
    static var ATTACHED_MELON_STEM;
    static var ATTACHED_PUMPKIN_STEM;
    static var AXOLOTL_BUCKET;
    static var AXOLOTL_SPAWN_EGG;
    static var AZALEA;
    static var AZALEA_LEAVES;
    static var AZURE_BLUET;
    static var BAKED_POTATO;
    static var BAMBOO;
    static var BAMBOO_SAPLING;
    static var BARREL;
    static var BARRIER;
    static var BASALT;
    static var BAT_SPAWN_EGG;
    static var BEACON;
    static var BEDROCK;
    static var BEEF;
    static var BEEHIVE;
    static var BEETROOT;
    static var BEETROOTS;
    static var BEETROOT_SEEDS;
    static var BEETROOT_SOUP;
    static var BEE_NEST;
    static var BEE_SPAWN_EGG;
    static var BELL;
    static var BIG_DRIPLEAF;
    static var BIG_DRIPLEAF_STEM;
    static var BIRCH_BOAT;
    static var BIRCH_BUTTON;
    static var BIRCH_CHEST_BOAT;
    static var BIRCH_DOOR;
    static var BIRCH_FENCE;
    static var BIRCH_FENCE_GATE;
    static var BIRCH_LEAVES;
    static var BIRCH_LOG;
    static var BIRCH_PLANKS;
    static var BIRCH_PRESSURE_PLATE;
    static var BIRCH_SAPLING;
    static var BIRCH_SIGN;
    static var BIRCH_SLAB;
    static var BIRCH_STAIRS;
    static var BIRCH_TRAPDOOR;
    static var BIRCH_WALL_SIGN;
    static var BIRCH_WOOD;
    static var BLACKSTONE;
    static var BLACKSTONE_SLAB;
    static var BLACKSTONE_STAIRS;
    static var BLACKSTONE_WALL;
    static var BLACK_BANNER;
    static var BLACK_BED;
    static var BLACK_CANDLE;
    static var BLACK_CANDLE_CAKE;
    static var BLACK_CARPET;
    static var BLACK_CONCRETE;
    static var BLACK_CONCRETE_POWDER;
    static var BLACK_DYE;
    static var BLACK_GLAZED_TERRACOTTA;
    static var BLACK_SHULKER_BOX;
    static var BLACK_STAINED_GLASS;
    static var BLACK_STAINED_GLASS_PANE;
    static var BLACK_TERRACOTTA;
    static var BLACK_WALL_BANNER;
    static var BLACK_WOOL;
    static var BLAST_FURNACE;
    static var BLAZE_POWDER;
    static var BLAZE_ROD;
    static var BLAZE_SPAWN_EGG;
    static var BLUE_BANNER;
    static var BLUE_BED;
    static var BLUE_CANDLE;
    static var BLUE_CANDLE_CAKE;
    static var BLUE_CARPET;
    static var BLUE_CONCRETE;
    static var BLUE_CONCRETE_POWDER;
    static var BLUE_DYE;
    static var BLUE_GLAZED_TERRACOTTA;
    static var BLUE_ICE;
    static var BLUE_ORCHID;
    static var BLUE_SHULKER_BOX;
    static var BLUE_STAINED_GLASS;
    static var BLUE_STAINED_GLASS_PANE;
    static var BLUE_TERRACOTTA;
    static var BLUE_WALL_BANNER;
    static var BLUE_WOOL;
    static var BONE;
    static var BONE_BLOCK;
    static var BONE_MEAL;
    static var BOOK;
    static var BOOKSHELF;
    static var BOW;
    static var BOWL;
    static var BRAIN_CORAL;
    static var BRAIN_CORAL_BLOCK;
    static var BRAIN_CORAL_FAN;
    static var BRAIN_CORAL_WALL_FAN;
    static var BREAD;
    static var BREWING_STAND;
    static var BRICK;
    static var BRICKS;
    static var BRICK_SLAB;
    static var BRICK_STAIRS;
    static var BRICK_WALL;
    static var BROWN_BANNER;
    static var BROWN_BED;
    static var BROWN_CANDLE;
    static var BROWN_CANDLE_CAKE;
    static var BROWN_CARPET;
    static var BROWN_CONCRETE;
    static var BROWN_CONCRETE_POWDER;
    static var BROWN_DYE;
    static var BROWN_GLAZED_TERRACOTTA;
    static var BROWN_MUSHROOM;
    static var BROWN_MUSHROOM_BLOCK;
    static var BROWN_SHULKER_BOX;
    static var BROWN_STAINED_GLASS;
    static var BROWN_STAINED_GLASS_PANE;
    static var BROWN_TERRACOTTA;
    static var BROWN_WALL_BANNER;
    static var BROWN_WOOL;
    static var BUBBLE_COLUMN;
    static var BUBBLE_CORAL;
    static var BUBBLE_CORAL_BLOCK;
    static var BUBBLE_CORAL_FAN;
    static var BUBBLE_CORAL_WALL_FAN;
    static var BUCKET;
    static var BUDDING_AMETHYST;
    static var BUNDLE;
    static var CACTUS;
    static var CAKE;
    static var CALCITE;
    static var CAMPFIRE;
    static var CANDLE;
    static var CANDLE_CAKE;
    static var CARROT;
    static var CARROTS;
    static var CARROT_ON_A_STICK;
    static var CARTOGRAPHY_TABLE;
    static var CARVED_PUMPKIN;
    static var CAT_SPAWN_EGG;
    static var CAULDRON;
    static var CAVE_AIR;
    static var CAVE_SPIDER_SPAWN_EGG;
    static var CAVE_VINES;
    static var CAVE_VINES_PLANT;
    static var CHAIN;
    static var CHAINMAIL_BOOTS;
    static var CHAINMAIL_CHESTPLATE;
    static var CHAINMAIL_HELMET;
    static var CHAINMAIL_LEGGINGS;
    static var CHAIN_COMMAND_BLOCK;
    static var CHARCOAL;
    static var CHEST;
    static var CHEST_MINECART;
    static var CHICKEN;
    static var CHICKEN_SPAWN_EGG;
    static var CHIPPED_ANVIL;
    static var CHISELED_DEEPSLATE;
    static var CHISELED_NETHER_BRICKS;
    static var CHISELED_POLISHED_BLACKSTONE;
    static var CHISELED_QUARTZ_BLOCK;
    static var CHISELED_RED_SANDSTONE;
    static var CHISELED_SANDSTONE;
    static var CHISELED_STONE_BRICKS;
    static var CHORUS_FLOWER;
    static var CHORUS_FRUIT;
    static var CHORUS_PLANT;
    static var CLAY;
    static var CLAY_BALL;
    static var CLOCK;
    static var COAL;
    static var COAL_BLOCK;
    static var COAL_ORE;
    static var COARSE_DIRT;
    static var COBBLED_DEEPSLATE;
    static var COBBLED_DEEPSLATE_SLAB;
    static var COBBLED_DEEPSLATE_STAIRS;
    static var COBBLED_DEEPSLATE_WALL;
    static var COBBLESTONE;
    static var COBBLESTONE_SLAB;
    static var COBBLESTONE_STAIRS;
    static var COBBLESTONE_WALL;
    static var COBWEB;
    static var COCOA;
    static var COCOA_BEANS;
    static var COD;
    static var COD_BUCKET;
    static var COD_SPAWN_EGG;
    static var COMMAND_BLOCK;
    static var COMMAND_BLOCK_MINECART;
    static var COMPARATOR;
    static var COMPASS;
    static var COMPOSTER;
    static var CONDUIT;
    static var COOKED_BEEF;
    static var COOKED_CHICKEN;
    static var COOKED_COD;
    static var COOKED_MUTTON;
    static var COOKED_PORKCHOP;
    static var COOKED_RABBIT;
    static var COOKED_SALMON;
    static var COOKIE;
    static var COPPER_BLOCK;
    static var COPPER_INGOT;
    static var COPPER_ORE;
    static var CORNFLOWER;
    static var COW_SPAWN_EGG;
    static var CRACKED_DEEPSLATE_BRICKS;
    static var CRACKED_DEEPSLATE_TILES;
    static var CRACKED_NETHER_BRICKS;
    static var CRACKED_POLISHED_BLACKSTONE_BRICKS;
    static var CRACKED_STONE_BRICKS;
    static var CRAFTING_TABLE;
    static var CREEPER_BANNER_PATTERN;
    static var CREEPER_HEAD;
    static var CREEPER_SPAWN_EGG;
    static var CREEPER_WALL_HEAD;
    static var CRIMSON_BUTTON;
    static var CRIMSON_DOOR;
    static var CRIMSON_FENCE;
    static var CRIMSON_FENCE_GATE;
    static var CRIMSON_FUNGUS;
    static var CRIMSON_HYPHAE;
    static var CRIMSON_NYLIUM;
    static var CRIMSON_PLANKS;
    static var CRIMSON_PRESSURE_PLATE;
    static var CRIMSON_ROOTS;
    static var CRIMSON_SIGN;
    static var CRIMSON_SLAB;
    static var CRIMSON_STAIRS;
    static var CRIMSON_STEM;
    static var CRIMSON_TRAPDOOR;
    static var CRIMSON_WALL_SIGN;
    static var CROSSBOW;
    static var CRYING_OBSIDIAN;
    static var CUT_COPPER;
    static var CUT_COPPER_SLAB;
    static var CUT_COPPER_STAIRS;
    static var CUT_RED_SANDSTONE;
    static var CUT_RED_SANDSTONE_SLAB;
    static var CUT_SANDSTONE;
    static var CUT_SANDSTONE_SLAB;
    static var CYAN_BANNER;
    static var CYAN_BED;
    static var CYAN_CANDLE;
    static var CYAN_CANDLE_CAKE;
    static var CYAN_CARPET;
    static var CYAN_CONCRETE;
    static var CYAN_CONCRETE_POWDER;
    static var CYAN_DYE;
    static var CYAN_GLAZED_TERRACOTTA;
    static var CYAN_SHULKER_BOX;
    static var CYAN_STAINED_GLASS;
    static var CYAN_STAINED_GLASS_PANE;
    static var CYAN_TERRACOTTA;
    static var CYAN_WALL_BANNER;
    static var CYAN_WOOL;
    static var DAMAGED_ANVIL;
    static var DANDELION;
    static var DARK_OAK_BOAT;
    static var DARK_OAK_BUTTON;
    static var DARK_OAK_CHEST_BOAT;
    static var DARK_OAK_DOOR;
    static var DARK_OAK_FENCE;
    static var DARK_OAK_FENCE_GATE;
    static var DARK_OAK_LEAVES;
    static var DARK_OAK_LOG;
    static var DARK_OAK_PLANKS;
    static var DARK_OAK_PRESSURE_PLATE;
    static var DARK_OAK_SAPLING;
    static var DARK_OAK_SIGN;
    static var DARK_OAK_SLAB;
    static var DARK_OAK_STAIRS;
    static var DARK_OAK_TRAPDOOR;
    static var DARK_OAK_WALL_SIGN;
    static var DARK_OAK_WOOD;
    static var DARK_PRISMARINE;
    static var DARK_PRISMARINE_SLAB;
    static var DARK_PRISMARINE_STAIRS;
    static var DAYLIGHT_DETECTOR;
    static var DEAD_BRAIN_CORAL;
    static var DEAD_BRAIN_CORAL_BLOCK;
    static var DEAD_BRAIN_CORAL_FAN;
    static var DEAD_BRAIN_CORAL_WALL_FAN;
    static var DEAD_BUBBLE_CORAL;
    static var DEAD_BUBBLE_CORAL_BLOCK;
    static var DEAD_BUBBLE_CORAL_FAN;
    static var DEAD_BUBBLE_CORAL_WALL_FAN;
    static var DEAD_BUSH;
    static var DEAD_FIRE_CORAL;
    static var DEAD_FIRE_CORAL_BLOCK;
    static var DEAD_FIRE_CORAL_FAN;
    static var DEAD_FIRE_CORAL_WALL_FAN;
    static var DEAD_HORN_CORAL;
    static var DEAD_HORN_CORAL_BLOCK;
    static var DEAD_HORN_CORAL_FAN;
    static var DEAD_HORN_CORAL_WALL_FAN;
    static var DEAD_TUBE_CORAL;
    static var DEAD_TUBE_CORAL_BLOCK;
    static var DEAD_TUBE_CORAL_FAN;
    static var DEAD_TUBE_CORAL_WALL_FAN;
    static var DEBUG_STICK;
    static var DEEPSLATE;
    static var DEEPSLATE_BRICKS;
    static var DEEPSLATE_BRICK_SLAB;
    static var DEEPSLATE_BRICK_STAIRS;
    static var DEEPSLATE_BRICK_WALL;
    static var DEEPSLATE_COAL_ORE;
    static var DEEPSLATE_COPPER_ORE;
    static var DEEPSLATE_DIAMOND_ORE;
    static var DEEPSLATE_EMERALD_ORE;
    static var DEEPSLATE_GOLD_ORE;
    static var DEEPSLATE_IRON_ORE;
    static var DEEPSLATE_LAPIS_ORE;
    static var DEEPSLATE_REDSTONE_ORE;
    static var DEEPSLATE_TILES;
    static var DEEPSLATE_TILE_SLAB;
    static var DEEPSLATE_TILE_STAIRS;
    static var DEEPSLATE_TILE_WALL;
    static var DETECTOR_RAIL;
    static var DIAMOND;
    static var DIAMOND_AXE;
    static var DIAMOND_BLOCK;
    static var DIAMOND_BOOTS;
    static var DIAMOND_CHESTPLATE;
    static var DIAMOND_HELMET;
    static var DIAMOND_HOE;
    static var DIAMOND_HORSE_ARMOR;
    static var DIAMOND_LEGGINGS;
    static var DIAMOND_ORE;
    static var DIAMOND_PICKAXE;
    static var DIAMOND_SHOVEL;
    static var DIAMOND_SWORD;
    static var DIORITE;
    static var DIORITE_SLAB;
    static var DIORITE_STAIRS;
    static var DIORITE_WALL;
    static var DIRT;
    static var DIRT_PATH;
    static var DISC_FRAGMENT_5;
    static var DISPENSER;
    static var DOLPHIN_SPAWN_EGG;
    static var DONKEY_SPAWN_EGG;
    static var DRAGON_BREATH;
    static var DRAGON_EGG;
    static var DRAGON_HEAD;
    static var DRAGON_WALL_HEAD;
    static var DRIED_KELP;
    static var DRIED_KELP_BLOCK;
    static var DRIPSTONE_BLOCK;
    static var DROPPER;
    static var DROWNED_SPAWN_EGG;
    static var ECHO_SHARD;
    static var EGG;
    static var ELDER_GUARDIAN_SPAWN_EGG;
    static var ELYTRA;
    static var EMERALD;
    static var EMERALD_BLOCK;
    static var EMERALD_ORE;
    static var ENCHANTED_BOOK;
    static var ENCHANTED_GOLDEN_APPLE;
    static var ENCHANTING_TABLE;
    static var ENDERMAN_SPAWN_EGG;
    static var ENDERMITE_SPAWN_EGG;
    static var ENDER_CHEST;
    static var ENDER_EYE;
    static var ENDER_PEARL;
    static var END_CRYSTAL;
    static var END_GATEWAY;
    static var END_PORTAL;
    static var END_PORTAL_FRAME;
    static var END_ROD;
    static var END_STONE;
    static var END_STONE_BRICKS;
    static var END_STONE_BRICK_SLAB;
    static var END_STONE_BRICK_STAIRS;
    static var END_STONE_BRICK_WALL;
    static var EVOKER_SPAWN_EGG;
    static var EXPERIENCE_BOTTLE;
    static var EXPOSED_COPPER;
    static var EXPOSED_CUT_COPPER;
    static var EXPOSED_CUT_COPPER_SLAB;
    static var EXPOSED_CUT_COPPER_STAIRS;
    static var FARMLAND;
    static var FEATHER;
    static var FERMENTED_SPIDER_EYE;
    static var FERN;
    static var FILLED_MAP;
    static var FIRE;
    static var FIREWORK_ROCKET;
    static var FIREWORK_STAR;
    static var FIRE_CHARGE;
    static var FIRE_CORAL;
    static var FIRE_CORAL_BLOCK;
    static var FIRE_CORAL_FAN;
    static var FIRE_CORAL_WALL_FAN;
    static var FISHING_ROD;
    static var FLETCHING_TABLE;
    static var FLINT;
    static var FLINT_AND_STEEL;
    static var FLOWERING_AZALEA;
    static var FLOWERING_AZALEA_LEAVES;
    static var FLOWER_BANNER_PATTERN;
    static var FLOWER_POT;
    static var FOX_SPAWN_EGG;
    static var FROGSPAWN;
    static var FROG_SPAWN_EGG;
    static var FROSTED_ICE;
    static var FURNACE;
    static var FURNACE_MINECART;
    static var GHAST_SPAWN_EGG;
    static var GHAST_TEAR;
    static var GILDED_BLACKSTONE;
    static var GLASS;
    static var GLASS_BOTTLE;
    static var GLASS_PANE;
    static var GLISTERING_MELON_SLICE;
    static var GLOBE_BANNER_PATTERN;
    static var GLOWSTONE;
    static var GLOWSTONE_DUST;
    static var GLOW_BERRIES;
    static var GLOW_INK_SAC;
    static var GLOW_ITEM_FRAME;
    static var GLOW_LICHEN;
    static var GLOW_SQUID_SPAWN_EGG;
    static var GOAT_HORN;
    static var GOAT_SPAWN_EGG;
    static var GOLDEN_APPLE;
    static var GOLDEN_AXE;
    static var GOLDEN_BOOTS;
    static var GOLDEN_CARROT;
    static var GOLDEN_CHESTPLATE;
    static var GOLDEN_HELMET;
    static var GOLDEN_HOE;
    static var GOLDEN_HORSE_ARMOR;
    static var GOLDEN_LEGGINGS;
    static var GOLDEN_PICKAXE;
    static var GOLDEN_SHOVEL;
    static var GOLDEN_SWORD;
    static var GOLD_BLOCK;
    static var GOLD_INGOT;
    static var GOLD_NUGGET;
    static var GOLD_ORE;
    static var GRANITE;
    static var GRANITE_SLAB;
    static var GRANITE_STAIRS;
    static var GRANITE_WALL;
    static var GRASS;
    static var GRASS_BLOCK;
    static var GRAVEL;
    static var GRAY_BANNER;
    static var GRAY_BED;
    static var GRAY_CANDLE;
    static var GRAY_CANDLE_CAKE;
    static var GRAY_CARPET;
    static var GRAY_CONCRETE;
    static var GRAY_CONCRETE_POWDER;
    static var GRAY_DYE;
    static var GRAY_GLAZED_TERRACOTTA;
    static var GRAY_SHULKER_BOX;
    static var GRAY_STAINED_GLASS;
    static var GRAY_STAINED_GLASS_PANE;
    static var GRAY_TERRACOTTA;
    static var GRAY_WALL_BANNER;
    static var GRAY_WOOL;
    static var GREEN_BANNER;
    static var GREEN_BED;
    static var GREEN_CANDLE;
    static var GREEN_CANDLE_CAKE;
    static var GREEN_CARPET;
    static var GREEN_CONCRETE;
    static var GREEN_CONCRETE_POWDER;
    static var GREEN_DYE;
    static var GREEN_GLAZED_TERRACOTTA;
    static var GREEN_SHULKER_BOX;
    static var GREEN_STAINED_GLASS;
    static var GREEN_STAINED_GLASS_PANE;
    static var GREEN_TERRACOTTA;
    static var GREEN_WALL_BANNER;
    static var GREEN_WOOL;
    static var GRINDSTONE;
    static var GUARDIAN_SPAWN_EGG;
    static var GUNPOWDER;
    static var HANGING_ROOTS;
    static var HAY_BLOCK;
    static var HEART_OF_THE_SEA;
    static var HEAVY_WEIGHTED_PRESSURE_PLATE;
    static var HOGLIN_SPAWN_EGG;
    static var HONEYCOMB;
    static var HONEYCOMB_BLOCK;
    static var HONEY_BLOCK;
    static var HONEY_BOTTLE;
    static var HOPPER;
    static var HOPPER_MINECART;
    static var HORN_CORAL;
    static var HORN_CORAL_BLOCK;
    static var HORN_CORAL_FAN;
    static var HORN_CORAL_WALL_FAN;
    static var HORSE_SPAWN_EGG;
    static var HUSK_SPAWN_EGG;
    static var ICE;
    static var INFESTED_CHISELED_STONE_BRICKS;
    static var INFESTED_COBBLESTONE;
    static var INFESTED_CRACKED_STONE_BRICKS;
    static var INFESTED_DEEPSLATE;
    static var INFESTED_MOSSY_STONE_BRICKS;
    static var INFESTED_STONE;
    static var INFESTED_STONE_BRICKS;
    static var INK_SAC;
    static var IRON_AXE;
    static var IRON_BARS;
    static var IRON_BLOCK;
    static var IRON_BOOTS;
    static var IRON_CHESTPLATE;
    static var IRON_DOOR;
    static var IRON_HELMET;
    static var IRON_HOE;
    static var IRON_HORSE_ARMOR;
    static var IRON_INGOT;
    static var IRON_LEGGINGS;
    static var IRON_NUGGET;
    static var IRON_ORE;
    static var IRON_PICKAXE;
    static var IRON_SHOVEL;
    static var IRON_SWORD;
    static var IRON_TRAPDOOR;
    static var ITEM_FRAME;
    static var JACK_O_LANTERN;
    static var JIGSAW;
    static var JUKEBOX;
    static var JUNGLE_BOAT;
    static var JUNGLE_BUTTON;
    static var JUNGLE_CHEST_BOAT;
    static var JUNGLE_DOOR;
    static var JUNGLE_FENCE;
    static var JUNGLE_FENCE_GATE;
    static var JUNGLE_LEAVES;
    static var JUNGLE_LOG;
    static var JUNGLE_PLANKS;
    static var JUNGLE_PRESSURE_PLATE;
    static var JUNGLE_SAPLING;
    static var JUNGLE_SIGN;
    static var JUNGLE_SLAB;
    static var JUNGLE_STAIRS;
    static var JUNGLE_TRAPDOOR;
    static var JUNGLE_WALL_SIGN;
    static var JUNGLE_WOOD;
    static var KELP;
    static var KELP_PLANT;
    static var KNOWLEDGE_BOOK;
    static var LADDER;
    static var LANTERN;
    static var LAPIS_BLOCK;
    static var LAPIS_LAZULI;
    static var LAPIS_ORE;
    static var LARGE_AMETHYST_BUD;
    static var LARGE_FERN;
    static var LAVA;
    static var LAVA_BUCKET;
    static var LAVA_CAULDRON;
    static var LEAD;
    static var LEATHER;
    static var LEATHER_BOOTS;
    static var LEATHER_CHESTPLATE;
    static var LEATHER_HELMET;
    static var LEATHER_HORSE_ARMOR;
    static var LEATHER_LEGGINGS;
    static var LECTERN;
    static var LEVER;
    static var LIGHT;
    static var LIGHTNING_ROD;
    static var LIGHT_BLUE_BANNER;
    static var LIGHT_BLUE_BED;
    static var LIGHT_BLUE_CANDLE;
    static var LIGHT_BLUE_CANDLE_CAKE;
    static var LIGHT_BLUE_CARPET;
    static var LIGHT_BLUE_CONCRETE;
    static var LIGHT_BLUE_CONCRETE_POWDER;
    static var LIGHT_BLUE_DYE;
    static var LIGHT_BLUE_GLAZED_TERRACOTTA;
    static var LIGHT_BLUE_SHULKER_BOX;
    static var LIGHT_BLUE_STAINED_GLASS;
    static var LIGHT_BLUE_STAINED_GLASS_PANE;
    static var LIGHT_BLUE_TERRACOTTA;
    static var LIGHT_BLUE_WALL_BANNER;
    static var LIGHT_BLUE_WOOL;
    static var LIGHT_GRAY_BANNER;
    static var LIGHT_GRAY_BED;
    static var LIGHT_GRAY_CANDLE;
    static var LIGHT_GRAY_CANDLE_CAKE;
    static var LIGHT_GRAY_CARPET;
    static var LIGHT_GRAY_CONCRETE;
    static var LIGHT_GRAY_CONCRETE_POWDER;
    static var LIGHT_GRAY_DYE;
    static var LIGHT_GRAY_GLAZED_TERRACOTTA;
    static var LIGHT_GRAY_SHULKER_BOX;
    static var LIGHT_GRAY_STAINED_GLASS;
    static var LIGHT_GRAY_STAINED_GLASS_PANE;
    static var LIGHT_GRAY_TERRACOTTA;
    static var LIGHT_GRAY_WALL_BANNER;
    static var LIGHT_GRAY_WOOL;
    static var LIGHT_WEIGHTED_PRESSURE_PLATE;
    static var LILAC;
    static var LILY_OF_THE_VALLEY;
    static var LILY_PAD;
    static var LIME_BANNER;
    static var LIME_BED;
    static var LIME_CANDLE;
    static var LIME_CANDLE_CAKE;
    static var LIME_CARPET;
    static var LIME_CONCRETE;
    static var LIME_CONCRETE_POWDER;
    static var LIME_DYE;
    static var LIME_GLAZED_TERRACOTTA;
    static var LIME_SHULKER_BOX;
    static var LIME_STAINED_GLASS;
    static var LIME_STAINED_GLASS_PANE;
    static var LIME_TERRACOTTA;
    static var LIME_WALL_BANNER;
    static var LIME_WOOL;
    static var LINGERING_POTION;
    static var LLAMA_SPAWN_EGG;
    static var LODESTONE;
    static var LOOM;
    static var MAGENTA_BANNER;
    static var MAGENTA_BED;
    static var MAGENTA_CANDLE;
    static var MAGENTA_CANDLE_CAKE;
    static var MAGENTA_CARPET;
    static var MAGENTA_CONCRETE;
    static var MAGENTA_CONCRETE_POWDER;
    static var MAGENTA_DYE;
    static var MAGENTA_GLAZED_TERRACOTTA;
    static var MAGENTA_SHULKER_BOX;
    static var MAGENTA_STAINED_GLASS;
    static var MAGENTA_STAINED_GLASS_PANE;
    static var MAGENTA_TERRACOTTA;
    static var MAGENTA_WALL_BANNER;
    static var MAGENTA_WOOL;
    static var MAGMA_BLOCK;
    static var MAGMA_CREAM;
    static var MAGMA_CUBE_SPAWN_EGG;
    static var MANGROVE_BOAT;
    static var MANGROVE_BUTTON;
    static var MANGROVE_CHEST_BOAT;
    static var MANGROVE_DOOR;
    static var MANGROVE_FENCE;
    static var MANGROVE_FENCE_GATE;
    static var MANGROVE_LEAVES;
    static var MANGROVE_LOG;
    static var MANGROVE_PLANKS;
    static var MANGROVE_PRESSURE_PLATE;
    static var MANGROVE_PROPAGULE;
    static var MANGROVE_ROOTS;
    static var MANGROVE_SIGN;
    static var MANGROVE_SLAB;
    static var MANGROVE_STAIRS;
    static var MANGROVE_TRAPDOOR;
    static var MANGROVE_WALL_SIGN;
    static var MANGROVE_WOOD;
    static var MAP;
    static var MEDIUM_AMETHYST_BUD;
    static var MELON;
    static var MELON_SEEDS;
    static var MELON_SLICE;
    static var MELON_STEM;
    static var MILK_BUCKET;
    static var MINECART;
    static var MOJANG_BANNER_PATTERN;
    static var MOOSHROOM_SPAWN_EGG;
    static var MOSSY_COBBLESTONE;
    static var MOSSY_COBBLESTONE_SLAB;
    static var MOSSY_COBBLESTONE_STAIRS;
    static var MOSSY_COBBLESTONE_WALL;
    static var MOSSY_STONE_BRICKS;
    static var MOSSY_STONE_BRICK_SLAB;
    static var MOSSY_STONE_BRICK_STAIRS;
    static var MOSSY_STONE_BRICK_WALL;
    static var MOSS_BLOCK;
    static var MOSS_CARPET;
    static var MOVING_PISTON;
    static var MUD;
    static var MUDDY_MANGROVE_ROOTS;
    static var MUD_BRICKS;
    static var MUD_BRICK_SLAB;
    static var MUD_BRICK_STAIRS;
    static var MUD_BRICK_WALL;
    static var MULE_SPAWN_EGG;
    static var MUSHROOM_STEM;
    static var MUSHROOM_STEW;
    static var MUSIC_DISC_11;
    static var MUSIC_DISC_13;
    static var MUSIC_DISC_5;
    static var MUSIC_DISC_BLOCKS;
    static var MUSIC_DISC_CAT;
    static var MUSIC_DISC_CHIRP;
    static var MUSIC_DISC_FAR;
    static var MUSIC_DISC_MALL;
    static var MUSIC_DISC_MELLOHI;
    static var MUSIC_DISC_OTHERSIDE;
    static var MUSIC_DISC_PIGSTEP;
    static var MUSIC_DISC_STAL;
    static var MUSIC_DISC_STRAD;
    static var MUSIC_DISC_WAIT;
    static var MUSIC_DISC_WARD;
    static var MUTTON;
    static var MYCELIUM;
    static var NAME_TAG;
    static var NAUTILUS_SHELL;
    static var NETHERITE_AXE;
    static var NETHERITE_BLOCK;
    static var NETHERITE_BOOTS;
    static var NETHERITE_CHESTPLATE;
    static var NETHERITE_HELMET;
    static var NETHERITE_HOE;
    static var NETHERITE_INGOT;
    static var NETHERITE_LEGGINGS;
    static var NETHERITE_PICKAXE;
    static var NETHERITE_SCRAP;
    static var NETHERITE_SHOVEL;
    static var NETHERITE_SWORD;
    static var NETHERRACK;
    static var NETHER_BRICK;
    static var NETHER_BRICKS;
    static var NETHER_BRICK_FENCE;
    static var NETHER_BRICK_SLAB;
    static var NETHER_BRICK_STAIRS;
    static var NETHER_BRICK_WALL;
    static var NETHER_GOLD_ORE;
    static var NETHER_PORTAL;
    static var NETHER_QUARTZ_ORE;
    static var NETHER_SPROUTS;
    static var NETHER_STAR;
    static var NETHER_WART;
    static var NETHER_WART_BLOCK;
    static var NOTE_BLOCK;
    static var OAK_BOAT;
    static var OAK_BUTTON;
    static var OAK_CHEST_BOAT;
    static var OAK_DOOR;
    static var OAK_FENCE;
    static var OAK_FENCE_GATE;
    static var OAK_LEAVES;
    static var OAK_LOG;
    static var OAK_PLANKS;
    static var OAK_PRESSURE_PLATE;
    static var OAK_SAPLING;
    static var OAK_SIGN;
    static var OAK_SLAB;
    static var OAK_STAIRS;
    static var OAK_TRAPDOOR;
    static var OAK_WALL_SIGN;
    static var OAK_WOOD;
    static var OBSERVER;
    static var OBSIDIAN;
    static var OCELOT_SPAWN_EGG;
    static var OCHRE_FROGLIGHT;
    static var ORANGE_BANNER;
    static var ORANGE_BED;
    static var ORANGE_CANDLE;
    static var ORANGE_CANDLE_CAKE;
    static var ORANGE_CARPET;
    static var ORANGE_CONCRETE;
    static var ORANGE_CONCRETE_POWDER;
    static var ORANGE_DYE;
    static var ORANGE_GLAZED_TERRACOTTA;
    static var ORANGE_SHULKER_BOX;
    static var ORANGE_STAINED_GLASS;
    static var ORANGE_STAINED_GLASS_PANE;
    static var ORANGE_TERRACOTTA;
    static var ORANGE_TULIP;
    static var ORANGE_WALL_BANNER;
    static var ORANGE_WOOL;
    static var OXEYE_DAISY;
    static var OXIDIZED_COPPER;
    static var OXIDIZED_CUT_COPPER;
    static var OXIDIZED_CUT_COPPER_SLAB;
    static var OXIDIZED_CUT_COPPER_STAIRS;
    static var PACKED_ICE;
    static var PACKED_MUD;
    static var PAINTING;
    static var PANDA_SPAWN_EGG;
    static var PAPER;
    static var PARROT_SPAWN_EGG;
    static var PEARLESCENT_FROGLIGHT;
    static var PEONY;
    static var PETRIFIED_OAK_SLAB;
    static var PHANTOM_MEMBRANE;
    static var PHANTOM_SPAWN_EGG;
    static var PIGLIN_BANNER_PATTERN;
    static var PIGLIN_BRUTE_SPAWN_EGG;
    static var PIGLIN_SPAWN_EGG;
    static var PIG_SPAWN_EGG;
    static var PILLAGER_SPAWN_EGG;
    static var PINK_BANNER;
    static var PINK_BED;
    static var PINK_CANDLE;
    static var PINK_CANDLE_CAKE;
    static var PINK_CARPET;
    static var PINK_CONCRETE;
    static var PINK_CONCRETE_POWDER;
    static var PINK_DYE;
    static var PINK_GLAZED_TERRACOTTA;
    static var PINK_SHULKER_BOX;
    static var PINK_STAINED_GLASS;
    static var PINK_STAINED_GLASS_PANE;
    static var PINK_TERRACOTTA;
    static var PINK_TULIP;
    static var PINK_WALL_BANNER;
    static var PINK_WOOL;
    static var PISTON;
    static var PISTON_HEAD;
    static var PLAYER_HEAD;
    static var PLAYER_WALL_HEAD;
    static var PODZOL;
    static var POINTED_DRIPSTONE;
    static var POISONOUS_POTATO;
    static var POLAR_BEAR_SPAWN_EGG;
    static var POLISHED_ANDESITE;
    static var POLISHED_ANDESITE_SLAB;
    static var POLISHED_ANDESITE_STAIRS;
    static var POLISHED_BASALT;
    static var POLISHED_BLACKSTONE;
    static var POLISHED_BLACKSTONE_BRICKS;
    static var POLISHED_BLACKSTONE_BRICK_SLAB;
    static var POLISHED_BLACKSTONE_BRICK_STAIRS;
    static var POLISHED_BLACKSTONE_BRICK_WALL;
    static var POLISHED_BLACKSTONE_BUTTON;
    static var POLISHED_BLACKSTONE_PRESSURE_PLATE;
    static var POLISHED_BLACKSTONE_SLAB;
    static var POLISHED_BLACKSTONE_STAIRS;
    static var POLISHED_BLACKSTONE_WALL;
    static var POLISHED_DEEPSLATE;
    static var POLISHED_DEEPSLATE_SLAB;
    static var POLISHED_DEEPSLATE_STAIRS;
    static var POLISHED_DEEPSLATE_WALL;
    static var POLISHED_DIORITE;
    static var POLISHED_DIORITE_SLAB;
    static var POLISHED_DIORITE_STAIRS;
    static var POLISHED_GRANITE;
    static var POLISHED_GRANITE_SLAB;
    static var POLISHED_GRANITE_STAIRS;
    static var POPPED_CHORUS_FRUIT;
    static var POPPY;
    static var PORKCHOP;
    static var POTATO;
    static var POTATOES;
    static var POTION;
    static var POTTED_ACACIA_SAPLING;
    static var POTTED_ALLIUM;
    static var POTTED_AZALEA_BUSH;
    static var POTTED_AZURE_BLUET;
    static var POTTED_BAMBOO;
    static var POTTED_BIRCH_SAPLING;
    static var POTTED_BLUE_ORCHID;
    static var POTTED_BROWN_MUSHROOM;
    static var POTTED_CACTUS;
    static var POTTED_CORNFLOWER;
    static var POTTED_CRIMSON_FUNGUS;
    static var POTTED_CRIMSON_ROOTS;
    static var POTTED_DANDELION;
    static var POTTED_DARK_OAK_SAPLING;
    static var POTTED_DEAD_BUSH;
    static var POTTED_FERN;
    static var POTTED_FLOWERING_AZALEA_BUSH;
    static var POTTED_JUNGLE_SAPLING;
    static var POTTED_LILY_OF_THE_VALLEY;
    static var POTTED_MANGROVE_PROPAGULE;
    static var POTTED_OAK_SAPLING;
    static var POTTED_ORANGE_TULIP;
    static var POTTED_OXEYE_DAISY;
    static var POTTED_PINK_TULIP;
    static var POTTED_POPPY;
    static var POTTED_RED_MUSHROOM;
    static var POTTED_RED_TULIP;
    static var POTTED_SPRUCE_SAPLING;
    static var POTTED_WARPED_FUNGUS;
    static var POTTED_WARPED_ROOTS;
    static var POTTED_WHITE_TULIP;
    static var POTTED_WITHER_ROSE;
    static var POWDER_SNOW;
    static var POWDER_SNOW_BUCKET;
    static var POWDER_SNOW_CAULDRON;
    static var POWERED_RAIL;
    static var PRISMARINE;
    static var PRISMARINE_BRICKS;
    static var PRISMARINE_BRICK_SLAB;
    static var PRISMARINE_BRICK_STAIRS;
    static var PRISMARINE_CRYSTALS;
    static var PRISMARINE_SHARD;
    static var PRISMARINE_SLAB;
    static var PRISMARINE_STAIRS;
    static var PRISMARINE_WALL;
    static var PUFFERFISH;
    static var PUFFERFISH_BUCKET;
    static var PUFFERFISH_SPAWN_EGG;
    static var PUMPKIN;
    static var PUMPKIN_PIE;
    static var PUMPKIN_SEEDS;
    static var PUMPKIN_STEM;
    static var PURPLE_BANNER;
    static var PURPLE_BED;
    static var PURPLE_CANDLE;
    static var PURPLE_CANDLE_CAKE;
    static var PURPLE_CARPET;
    static var PURPLE_CONCRETE;
    static var PURPLE_CONCRETE_POWDER;
    static var PURPLE_DYE;
    static var PURPLE_GLAZED_TERRACOTTA;
    static var PURPLE_SHULKER_BOX;
    static var PURPLE_STAINED_GLASS;
    static var PURPLE_STAINED_GLASS_PANE;
    static var PURPLE_TERRACOTTA;
    static var PURPLE_WALL_BANNER;
    static var PURPLE_WOOL;
    static var PURPUR_BLOCK;
    static var PURPUR_PILLAR;
    static var PURPUR_SLAB;
    static var PURPUR_STAIRS;
    static var QUARTZ;
    static var QUARTZ_BLOCK;
    static var QUARTZ_BRICKS;
    static var QUARTZ_PILLAR;
    static var QUARTZ_SLAB;
    static var QUARTZ_STAIRS;
    static var RABBIT;
    static var RABBIT_FOOT;
    static var RABBIT_HIDE;
    static var RABBIT_SPAWN_EGG;
    static var RABBIT_STEW;
    static var RAIL;
    static var RAVAGER_SPAWN_EGG;
    static var RAW_COPPER;
    static var RAW_COPPER_BLOCK;
    static var RAW_GOLD;
    static var RAW_GOLD_BLOCK;
    static var RAW_IRON;
    static var RAW_IRON_BLOCK;
    static var RECOVERY_COMPASS;
    static var REDSTONE;
    static var REDSTONE_BLOCK;
    static var REDSTONE_LAMP;
    static var REDSTONE_ORE;
    static var REDSTONE_TORCH;
    static var REDSTONE_WALL_TORCH;
    static var REDSTONE_WIRE;
    static var RED_BANNER;
    static var RED_BED;
    static var RED_CANDLE;
    static var RED_CANDLE_CAKE;
    static var RED_CARPET;
    static var RED_CONCRETE;
    static var RED_CONCRETE_POWDER;
    static var RED_DYE;
    static var RED_GLAZED_TERRACOTTA;
    static var RED_MUSHROOM;
    static var RED_MUSHROOM_BLOCK;
    static var RED_NETHER_BRICKS;
    static var RED_NETHER_BRICK_SLAB;
    static var RED_NETHER_BRICK_STAIRS;
    static var RED_NETHER_BRICK_WALL;
    static var RED_SAND;
    static var RED_SANDSTONE;
    static var RED_SANDSTONE_SLAB;
    static var RED_SANDSTONE_STAIRS;
    static var RED_SANDSTONE_WALL;
    static var RED_SHULKER_BOX;
    static var RED_STAINED_GLASS;
    static var RED_STAINED_GLASS_PANE;
    static var RED_TERRACOTTA;
    static var RED_TULIP;
    static var RED_WALL_BANNER;
    static var RED_WOOL;
    static var REINFORCED_DEEPSLATE;
    static var REPEATER;
    static var REPEATING_COMMAND_BLOCK;
    static var RESPAWN_ANCHOR;
    static var ROOTED_DIRT;
    static var ROSE_BUSH;
    static var ROTTEN_FLESH;
    static var SADDLE;
    static var SALMON;
    static var SALMON_BUCKET;
    static var SALMON_SPAWN_EGG;
    static var SAND;
    static var SANDSTONE;
    static var SANDSTONE_SLAB;
    static var SANDSTONE_STAIRS;
    static var SANDSTONE_WALL;
    static var SCAFFOLDING;
    static var SCULK;
    static var SCULK_CATALYST;
    static var SCULK_SENSOR;
    static var SCULK_SHRIEKER;
    static var SCULK_VEIN;
    static var SCUTE;
    static var SEAGRASS;
    static var SEA_LANTERN;
    static var SEA_PICKLE;
    static var SHEARS;
    static var SHEEP_SPAWN_EGG;
    static var SHIELD;
    static var SHROOMLIGHT;
    static var SHULKER_BOX;
    static var SHULKER_SHELL;
    static var SHULKER_SPAWN_EGG;
    static var SILVERFISH_SPAWN_EGG;
    static var SKELETON_HORSE_SPAWN_EGG;
    static var SKELETON_SKULL;
    static var SKELETON_SPAWN_EGG;
    static var SKELETON_WALL_SKULL;
    static var SKULL_BANNER_PATTERN;
    static var SLIME_BALL;
    static var SLIME_BLOCK;
    static var SLIME_SPAWN_EGG;
    static var SMALL_AMETHYST_BUD;
    static var SMALL_DRIPLEAF;
    static var SMITHING_TABLE;
    static var SMOKER;
    static var SMOOTH_BASALT;
    static var SMOOTH_QUARTZ;
    static var SMOOTH_QUARTZ_SLAB;
    static var SMOOTH_QUARTZ_STAIRS;
    static var SMOOTH_RED_SANDSTONE;
    static var SMOOTH_RED_SANDSTONE_SLAB;
    static var SMOOTH_RED_SANDSTONE_STAIRS;
    static var SMOOTH_SANDSTONE;
    static var SMOOTH_SANDSTONE_SLAB;
    static var SMOOTH_SANDSTONE_STAIRS;
    static var SMOOTH_STONE;
    static var SMOOTH_STONE_SLAB;
    static var SNOW;
    static var SNOWBALL;
    static var SNOW_BLOCK;
    static var SOUL_CAMPFIRE;
    static var SOUL_FIRE;
    static var SOUL_LANTERN;
    static var SOUL_SAND;
    static var SOUL_SOIL;
    static var SOUL_TORCH;
    static var SOUL_WALL_TORCH;
    static var SPAWNER;
    static var SPECTRAL_ARROW;
    static var SPIDER_EYE;
    static var SPIDER_SPAWN_EGG;
    static var SPLASH_POTION;
    static var SPONGE;
    static var SPORE_BLOSSOM;
    static var SPRUCE_BOAT;
    static var SPRUCE_BUTTON;
    static var SPRUCE_CHEST_BOAT;
    static var SPRUCE_DOOR;
    static var SPRUCE_FENCE;
    static var SPRUCE_FENCE_GATE;
    static var SPRUCE_LEAVES;
    static var SPRUCE_LOG;
    static var SPRUCE_PLANKS;
    static var SPRUCE_PRESSURE_PLATE;
    static var SPRUCE_SAPLING;
    static var SPRUCE_SIGN;
    static var SPRUCE_SLAB;
    static var SPRUCE_STAIRS;
    static var SPRUCE_TRAPDOOR;
    static var SPRUCE_WALL_SIGN;
    static var SPRUCE_WOOD;
    static var SPYGLASS;
    static var SQUID_SPAWN_EGG;
    static var STICK;
    static var STICKY_PISTON;
    static var STONE;
    static var STONECUTTER;
    static var STONE_AXE;
    static var STONE_BRICKS;
    static var STONE_BRICK_SLAB;
    static var STONE_BRICK_STAIRS;
    static var STONE_BRICK_WALL;
    static var STONE_BUTTON;
    static var STONE_HOE;
    static var STONE_PICKAXE;
    static var STONE_PRESSURE_PLATE;
    static var STONE_SHOVEL;
    static var STONE_SLAB;
    static var STONE_STAIRS;
    static var STONE_SWORD;
    static var STRAY_SPAWN_EGG;
    static var STRIDER_SPAWN_EGG;
    static var STRING;
    static var STRIPPED_ACACIA_LOG;
    static var STRIPPED_ACACIA_WOOD;
    static var STRIPPED_BIRCH_LOG;
    static var STRIPPED_BIRCH_WOOD;
    static var STRIPPED_CRIMSON_HYPHAE;
    static var STRIPPED_CRIMSON_STEM;
    static var STRIPPED_DARK_OAK_LOG;
    static var STRIPPED_DARK_OAK_WOOD;
    static var STRIPPED_JUNGLE_LOG;
    static var STRIPPED_JUNGLE_WOOD;
    static var STRIPPED_MANGROVE_LOG;
    static var STRIPPED_MANGROVE_WOOD;
    static var STRIPPED_OAK_LOG;
    static var STRIPPED_OAK_WOOD;
    static var STRIPPED_SPRUCE_LOG;
    static var STRIPPED_SPRUCE_WOOD;
    static var STRIPPED_WARPED_HYPHAE;
    static var STRIPPED_WARPED_STEM;
    static var STRUCTURE_BLOCK;
    static var STRUCTURE_VOID;
    static var SUGAR;
    static var SUGAR_CANE;
    static var SUNFLOWER;
    static var SUSPICIOUS_STEW;
    static var SWEET_BERRIES;
    static var SWEET_BERRY_BUSH;
    static var TADPOLE_BUCKET;
    static var TADPOLE_SPAWN_EGG;
    static var TALL_GRASS;
    static var TALL_SEAGRASS;
    static var TARGET;
    static var TERRACOTTA;
    static var TINTED_GLASS;
    static var TIPPED_ARROW;
    static var TNT;
    static var TNT_MINECART;
    static var TORCH;
    static var TOTEM_OF_UNDYING;
    static var TRADER_LLAMA_SPAWN_EGG;
    static var TRAPPED_CHEST;
    static var TRIDENT;
    static var TRIPWIRE;
    static var TRIPWIRE_HOOK;
    static var TROPICAL_FISH;
    static var TROPICAL_FISH_BUCKET;
    static var TROPICAL_FISH_SPAWN_EGG;
    static var TUBE_CORAL;
    static var TUBE_CORAL_BLOCK;
    static var TUBE_CORAL_FAN;
    static var TUBE_CORAL_WALL_FAN;
    static var TUFF;
    static var TURTLE_EGG;
    static var TURTLE_HELMET;
    static var TURTLE_SPAWN_EGG;
    static var TWISTING_VINES;
    static var TWISTING_VINES_PLANT;
    static var VERDANT_FROGLIGHT;
    static var VEX_SPAWN_EGG;
    static var VILLAGER_SPAWN_EGG;
    static var VINDICATOR_SPAWN_EGG;
    static var VINE;
    static var VOID_AIR;
    static var WALL_TORCH;
    static var WANDERING_TRADER_SPAWN_EGG;
    static var WARDEN_SPAWN_EGG;
    static var WARPED_BUTTON;
    static var WARPED_DOOR;
    static var WARPED_FENCE;
    static var WARPED_FENCE_GATE;
    static var WARPED_FUNGUS;
    static var WARPED_FUNGUS_ON_A_STICK;
    static var WARPED_HYPHAE;
    static var WARPED_NYLIUM;
    static var WARPED_PLANKS;
    static var WARPED_PRESSURE_PLATE;
    static var WARPED_ROOTS;
    static var WARPED_SIGN;
    static var WARPED_SLAB;
    static var WARPED_STAIRS;
    static var WARPED_STEM;
    static var WARPED_TRAPDOOR;
    static var WARPED_WALL_SIGN;
    static var WARPED_WART_BLOCK;
    static var WATER;
    static var WATER_BUCKET;
    static var WATER_CAULDRON;
    static var WAXED_COPPER_BLOCK;
    static var WAXED_CUT_COPPER;
    static var WAXED_CUT_COPPER_SLAB;
    static var WAXED_CUT_COPPER_STAIRS;
    static var WAXED_EXPOSED_COPPER;
    static var WAXED_EXPOSED_CUT_COPPER;
    static var WAXED_EXPOSED_CUT_COPPER_SLAB;
    static var WAXED_EXPOSED_CUT_COPPER_STAIRS;
    static var WAXED_OXIDIZED_COPPER;
    static var WAXED_OXIDIZED_CUT_COPPER;
    static var WAXED_OXIDIZED_CUT_COPPER_SLAB;
    static var WAXED_OXIDIZED_CUT_COPPER_STAIRS;
    static var WAXED_WEATHERED_COPPER;
    static var WAXED_WEATHERED_CUT_COPPER;
    static var WAXED_WEATHERED_CUT_COPPER_SLAB;
    static var WAXED_WEATHERED_CUT_COPPER_STAIRS;
    static var WEATHERED_COPPER;
    static var WEATHERED_CUT_COPPER;
    static var WEATHERED_CUT_COPPER_SLAB;
    static var WEATHERED_CUT_COPPER_STAIRS;
    static var WEEPING_VINES;
    static var WEEPING_VINES_PLANT;
    static var WET_SPONGE;
    static var WHEAT;
    static var WHEAT_SEEDS;
    static var WHITE_BANNER;
    static var WHITE_BED;
    static var WHITE_CANDLE;
    static var WHITE_CANDLE_CAKE;
    static var WHITE_CARPET;
    static var WHITE_CONCRETE;
    static var WHITE_CONCRETE_POWDER;
    static var WHITE_DYE;
    static var WHITE_GLAZED_TERRACOTTA;
    static var WHITE_SHULKER_BOX;
    static var WHITE_STAINED_GLASS;
    static var WHITE_STAINED_GLASS_PANE;
    static var WHITE_TERRACOTTA;
    static var WHITE_TULIP;
    static var WHITE_WALL_BANNER;
    static var WHITE_WOOL;
    static var WITCH_SPAWN_EGG;
    static var WITHER_ROSE;
    static var WITHER_SKELETON_SKULL;
    static var WITHER_SKELETON_SPAWN_EGG;
    static var WITHER_SKELETON_WALL_SKULL;
    static var WOLF_SPAWN_EGG;
    static var WOODEN_AXE;
    static var WOODEN_HOE;
    static var WOODEN_PICKAXE;
    static var WOODEN_SHOVEL;
    static var WOODEN_SWORD;
    static var WRITABLE_BOOK;
    static var WRITTEN_BOOK;
    static var YELLOW_BANNER;
    static var YELLOW_BED;
    static var YELLOW_CANDLE;
    static var YELLOW_CANDLE_CAKE;
    static var YELLOW_CARPET;
    static var YELLOW_CONCRETE;
    static var YELLOW_CONCRETE_POWDER;
    static var YELLOW_DYE;
    static var YELLOW_GLAZED_TERRACOTTA;
    static var YELLOW_SHULKER_BOX;
    static var YELLOW_STAINED_GLASS;
    static var YELLOW_STAINED_GLASS_PANE;
    static var YELLOW_TERRACOTTA;
    static var YELLOW_WALL_BANNER;
    static var YELLOW_WOOL;
    static var ZOGLIN_SPAWN_EGG;
    static var ZOMBIE_HEAD;
    static var ZOMBIE_HORSE_SPAWN_EGG;
    static var ZOMBIE_SPAWN_EGG;
    static var ZOMBIE_VILLAGER_SPAWN_EGG;
    static var ZOMBIE_WALL_HEAD;
    static var ZOMBIFIED_PIGLIN_SPAWN_EGG;

    /*
     * This gets the translated name of the ItemStack, for example: 
     * Material.DIAMOND_SWORD would return 'Diamond Sword' if your language is English
     * Returns - String: the translated name of the Material
     */
    fun getTranslatedName();

    /*
     * This converts the material into a Block
     * Returns - Block: the Block representation of the material
     * Throws - Error: Material cannot be converted to a block
     */
    fun asBlock();

    /*
     * This returns the full id of the material, for example: 'minecraft:diamond'
     * Returns - String: the full id representation of the material
     */
    fun getFullId();

    /*
     * This returns the id of the material, for example: 'diamond'
     * Returns - String: the id representation of the material
     */
    fun getId();

    /*
     * This converts the material into an ItemStack
     * Returns - ItemStack: the ItemStack representation of the material
     * Throws - Error: Material cannot be converted to an item stack
     */
    fun asItemStack();

    /*
     * This converts a block or item id into a Material
     * Parameter - String (id): the id of the block or item
     * Returns - Material: the material instance from the id
     * Throws - Error: ... is not a valid Material
     */
    static fun of(id);
}

/* Native, implemented in Java
 * This class is a wrapper for 3 coordinate points in Minecraft
 * Import with 'import Pos from Minecraft'
 */
class Pos {
    /*
     * This creates a new Pos with the given x, y, and z
     * Parameter - Number (x): the x position
     * Parameter - Number (y): the y position
     * Parameter - Number (z): the z position
     */
    Pos(x, y, z);

    /*
     * This returns the x position of the Pos
     * Returns - Number: the x position
     */
    fun getX();

    /*
     * This returns the y position of the Pos
     * Returns - Number: the y position
     */
    fun getY();

    /*
     * This returns the z position of the Pos
     * Returns - Number: the z position
     */
    fun getZ();

    /*
     * This returns the Pos as a List containing the x, y, and z positions in order
     * Returns - List: the Pos as a List
     */
    fun toList();
}

/* Native, implemented in Java */
class Block {
    /*
     * This gets the properties of the Block
     * You can find a list of all block properties
     * [here](https://minecraft.fandom.com/wiki/Java_Edition_data_values#Block_states)
     * Returns - Map: the properties of the Block, may be empty if there are no properties
     */
    fun getBlockProperties();

    /*
     * This checks if the Block has a position or not
     * Returns - Boolean: true if the Block has a position
     */
    fun hasBlockPosition();

    /*
     * This checks if the Block is solid on the full square
     * Parameter - String (side): the side to check, for example: 'north', 'south', 'east', 'west', 'up', 'down'
     * Returns - Boolean: true if the Block is solid on the full square
     */
    fun isSideSolidFullSquare(side);

    /*
     * This gets the full id of the Block, for example: 'minecraft:stone'
     * Returns - String: the full id of the Block
     */
    fun getFullId();

    /*
     * This checks if the Block covers a small square
     * Parameter - String (side): the side to check, for example: 'north', 'south', 'east', 'west', 'up', 'down'
     * Returns - Boolean: true if the Block covers a small square
     */
    fun sideCoversSmallSquare(side);

    /*
     * This gets the id of the Block, for example: 'stone'
     * Returns - String: the id of the Block
     */
    fun getId();

    /*
     * This checks if the Block is spawnable in the case of zombies
     * Returns - Boolean: true if the Block is spawnable in the case of zombies
     */
    fun isSpawnable();

    /*
     * This checks if the Block is spawnable in the case of the given entity
     * Parameter - Entity (entity): the entity to check
     * Returns - Boolean: true if the Block is spawnable in the case of the given entity
     */
    fun isSpawnable(entity);

    /*
     * This mirrors the Block around the front and back
     * Returns - Block: the mirrored Block
     */
    fun mirrorFrontBack();

    /*
     * This mirrors the Block around the left and right
     * Returns - Block: the mirrored Block
     */
    fun mirrorLeftRight();

    /*
     * This gets the position of the Block
     * Returns - Pos: the position of the Block, may be null if the Block has no position
     */
    fun getPos();

    /*
     * This checks if the Block is a solid block
     * Returns - Boolean: true if the Block is a solid block
     */
    fun isSolidBlock();

    /*
     * This checks if the Block is transparent
     * Returns - Boolean: true if the Block is transparent
     */
    fun isTransparent();

    /*
     * This checks if the Block is replaceable
     * Returns - Boolean: true if the Block is replaceable
     */
    fun isReplaceable();

    /*
     * This gets the luminance of the Block
     * Returns - Number: the luminance of the Block
     */
    fun getLuminance();

    /*
     * This rotates the Block 90 degrees counter-clockwise
     * Returns - Block: the rotated Block
     */
    fun rotateYCounterClockwise();

    /*
     * This checks if the Block is a fluid source
     * Returns - Boolean: true if the Block is a fluid source
     */
    fun isFluidSource();

    /*
     * This gets the ItemStack of the Block, if the block has no item it will return air
     * Returns - ItemStack: the ItemStack of the Block
     */
    fun asItemStack();

    /*
     * This gets the material of the Block
     * Returns - Material: the material of the Block
     */
    fun getMaterial();

    /*
     * This rotates the Block 90 degrees clockwise
     * Returns - Block: the rotated Block
     */
    fun rotateYClockwise();

    /*
     * This gets the translated name of the Block, for example
     * 'stone' would return 'Stone' if your language is in English
     * Returns - String: the translated name of the Block
     */
    fun getTranslatedName();

    /*
     * This gets the X position of the Block
     * Returns - Number: the X position of the Block, may be null if the Block has no position
     */
    fun getX();

    /*
     * This gets the Y position of the Block
     * Returns - Number: the Y position of the Block, may be null if the Block has no position
     */
    fun getY();

    /*
     * This gets the Z position of the Block
     * Returns - Number: the Z position of the Block, may be null if the Block has no position
     */
    fun getZ();

    /*
     * This gets the blast resistance of the Block
     * Returns - Number: the blast resistance of the Block
     */
    fun getBlastResistance();

    /*
     * This gets the hardness of the Block
     * Returns - Number: the hardness of the Block
     */
    fun getHardness();

    /*
     * This checks if the Block is a fluid
     * Returns - Boolean: true if the Block is a fluid
     */
    fun isFluid();

    fun getBlockEntityNbt();

    /*
     * This checks if the Block is a BlockEntity
     * Returns - Boolean: true if the Block is a BlockEntity
     */
    fun isBlockEntity();

    /*
     * This creates a Block from a material or string
     * Parameter - MaterialLike (material): the material, item stack, block, or string to create the Block from
     * Returns - Block: the Block created from the material or string
     */
    static fun of(material);
}

/* Native, implemented in Java
 * This class is used to create a sphere shape which can be rendered in the world.
 * Import with 'import SphereShape from Minecraft'
 */
class SphereShape {
    /*
     * This creates a new sphere shape
     * Parameter - Pos (pos): The position of the sphere
     */
    SphereShape(pos);

    /*
     * This creates a new sphere shape
     * Parameter - Number (x): The x position of the sphere
     * Parameter - Number (y): The y position of the sphere
     * Parameter - Number (z): The z position of the sphere
     */
    SphereShape(x, y, z);

    /*
     * This sets the colour of the shape, using a single value, this
     * function also has a sibling named `setColor()` that has the same functionality
     * Parameter - Number (colour): the colour, usually you would use hexadecimal, 0xRRGGBB where RR represents red from 00 - FF, GG represents green from 00 - FF, and BB represents blue from 00 - FF
     */
    fun setColour(colour);

    /*
     * This sets the colour of the shape, using three values this function
     * also has a sibling named `setColor()` that has the same functionality
     * Parameter - Number (red): the amount of red 0 - 255
     * Parameter - Number (green): the amount of green 0 - 255
     * Parameter - Number (blue): the amount of blue 0 - 255
     * Throws - Error: Colour ... is out of bounds, must be between 0 - 255
     */
    fun setColour(red, green, blue);

    /*
     * This sets whether the shape should render through blocks
     * Parameter - Boolean (boolean): whether the shape should render through blocks
     */
    fun setRenderThroughBlocks(boolean);

    /*
     * This sets the z scale of the shape
     * Parameter - Number (zScale): the z scale of the shape
     */
    fun setZScale(zScale);

    /*
     * This returns the width of the shape
     * Returns - Number: the width of the shape
     */
    fun getWidth();

    /*
     * This sets the green value of the shape, using a single value
     * Parameter - Number (green): the amount of green between 0 - 255
     * Throws - Error: Colour ... is out of bounds, must be between 0 - 255
     */
    fun setGreen(green);

    /*
     * This sets the red value of the shape, using a single value
     * Parameter - Number (red): the amount of red between 0 - 255
     * Throws - Error: Colour ... is out of bounds, must be between 0 - 255
     */
    fun setRed(red);

    /*
     * This sets the outline green value of the shape, using a single value
     * Parameter - Number (green): the amount of green between 0 - 255
     */
    fun setOutlineGreen(green);

    /*
     * This gets the y tilt of the shape
     * Returns - Number: the y tilt
     */
    fun getYTilt();

    /*
     * This returns the position of the shape
     * Parameter - Pos (pos): the position of the shape
     */
    fun setPos(pos);

    /*
     * This returns the opacity of the shape
     * Returns - Number: the opacity of the shape
     */
    fun getOpacity();

    /*
     * This rounds the position to the nearest block position
     */
    fun centerPosition();

    /*
     * This sets the number of steps the sphere will take to render
     * Parameter - Number (steps): The number of steps
     */
    fun setSteps(steps);

    /*
     * This returns the red value of the shape
     * Returns - Number: the red value of the shape
     */
    fun getRed();

    /*
     * This sets the blue value of the shape, using a single value
     * Parameter - Number (blue): the amount of blue between 0 - 255
     * Throws - Error: Colour ... is out of bounds, must be between 0 - 255
     */
    fun setBlue(blue);

    /*
     * This returns the RGB value of the shape as a list
     * Returns - List: the RGB value of the shape as a list in the form [red, green, blue]
     */
    fun getRGBList();

    /*
     * This sets the outline pixel width of the shape, using a single value
     * Parameter - Number (width): the width of the outline in pixels
     */
    fun setOutlinePixelWidth(width);

    /*
     * This stops the shape from rendering
     */
    fun stopRendering();

    /*
     * This sets the y scale of the shape
     * Parameter - Number (yScale): the y scale of the shape
     */
    fun setYScale(yScale);

    /*
     * This gets the y scale of the shape
     */
    fun getYScale();

    /*
     * This gets the number of steps the sphere will take to render
     * Returns - Number: The number of steps
     */
    fun getSteps();

    /*
     * This returns the RGBA value of the shape as a list
     * Returns - List: the RGBA value of the shape as a list in the form [red, green, blue, opacity]
     */
    fun getRGBAList();

    /*
     * This gets the z tilt of the shape
     * Returns - Number: the z tilt
     */
    fun getZTilt();

    /*
     * This sets the shape to be rendered indefinitely, the shape will only stop rendering when the script ends or when you call the stopRendering() method
     */
    fun render();

    /*
     * This sets the z tilt of the shape
     * Parameter - Number (zTilt): the z tilt
     */
    fun setZTilt(zTilt);

    /*
     * This returns the RGB value of the shape
     * Returns - Number: the RGB value of the shape as a single number in the form 0xRRGGBB
     */
    fun getRGB();

    /*
     * This gets the z scale of the shape
     */
    fun getZScale();

    /*
     * This sets the x scale of the shape
     * Parameter - Number (xScale): the x scale of the shape
     */
    fun setXScale(xScale);

    /*
     * This sets the scale of the shape
     * Parameter - Number (xScale): the x scale of the shape
     * Parameter - Number (yScale): the y scale of the shape
     * Parameter - Number (zScale): the z scale of the shape
     */
    fun setScale(xScale, yScale, zScale);

    /*
     * This sets the outline red value of the shape, using a single value
     * Parameter - Number (red): the amount of red between 0 - 255
     */
    fun setOutlineRed(red);

    /*
     * This sets the y tilt of the shape
     * Parameter - Number (yTilt): the y tilt
     */
    fun setYTilt(yTilt);

    /*
     * This returns whether the shape should render through blocks
     * Returns - Boolean: whether the shape should render through blocks
     */
    fun shouldRenderThroughBlocks();

    /*
     * This sets the width of the shape
     * Parameter - Number (width): the width of the shape
     */
    fun setWidth(width);

    /*
     * This returns the blue value of the shape
     * Returns - Number: the blue value of the shape
     */
    fun getBlue();

    /*
     * This sets the tilt of the shape
     * Parameter - Number (xTilt): the x tilt
     * Parameter - Number (yTilt): the y tilt
     * Parameter - Number (zTilt): the z tilt
     */
    fun setTilt(xTilt, yTilt, zTilt);

    /*
     * This returns the green value of the shape
     * Returns - Number: the green value of the shape
     */
    fun getGreen();

    /*
     * This sets the width of the shape, using a single value, this function
     * also has a sibling named `setOutlineColor()` that has the same functionality
     * Parameter - Number (colour): the colour, usually you would use hexadecimal, 0xRRGGBB where RR represents red from 00 - FF, GG represents green from 00 - FF, and BB represents blue from 00 - FF
     */
    fun setOutlineColour(colour);

    /*
     * This sets the outline colour of the shape, using three values, this function
     * also has a sibling named `setOutlineColor()` that has the same functionality
     * Parameter - Number (red): the amount of red 0 - 255
     * Parameter - Number (green): the amount of green 0 - 255
     * Parameter - Number (blue): the amount of blue 0 - 255
     */
    fun setOutlineColour(red, green, blue);

    /*
     * This sets the outline blue value of the shape, using a single value
     * Parameter - Number (blue): the amount of blue between 0 - 255
     */
    fun setOutlineBlue(blue);

    /*
     * This sets the colour of the shape, using a single value, this
     * Parameter - Number (colour): the colour, usually you would use hexadecimal, 0xRRGGBB where RR represents red from 00 - FF, GG represents green from 00 - FF, and BB represents blue from 00 - FF
     */
    fun setColor(colour);

    /*
     * This sets the colour of the shape, using three values this function
     * Parameter - Number (red): the amount of red 0 - 255
     * Parameter - Number (green): the amount of green 0 - 255
     * Parameter - Number (blue): the amount of blue 0 - 255
     * Throws - Error: Colour ... is out of bounds, must be between 0 - 255
     */
    fun setColor(red, green, blue);

    /*
     * This gets the x scale of the shape
     */
    fun getXScale();

    /*
     * This sets the width of the shape, using a single value, this function
     * Parameter - Number (colour): the colour, usually you would use hexadecimal, 0xRRGGBB where RR represents red from 00 - FF, GG represents green from 00 - FF, and BB represents blue from 00 - FF
     */
    fun setOutlineColor(colour);

    /*
     * This sets the outline colour of the shape, using three values, this function
     * Parameter - Number (red): the amount of red 0 - 255
     * Parameter - Number (green): the amount of green 0 - 255
     * Parameter - Number (blue): the amount of blue 0 - 255
     */
    fun setOutlineColor(red, green, blue);

    /*
     * This sets the x tilt of the shape
     * Parameter - Number (xTilt): the x tilt
     */
    fun setXTilt(xTilt);

    /*
     * This gets the x tilt of the shape
     * Returns - Number: the x tilt
     */
    fun getXTilt();

    /*
     * This sets the opacity of the shape, using a single value
     * Parameter - Number (alpha): the opacity, where 255 is solid colour and 0 is no colour
     * Throws - Error: Colour ... is out of bounds, must be between 0 - 255
     */
    fun setOpacity(alpha);
}

/* Native, implemented in Java
 * This class allows you to build commands for Minecraft.
 * Import with 'import CommandBuilder from Minecraft'
 */
class CommandBuilder {
    /*
     * This sets the function to be executed when the command is executed,
     * this should have the correct amount of parameters for the command
     * Parameter - CommandBuilder (function): the function to execute
     * Returns - CommandBuilder: the parent command builder
     */
    fun executes(function);

    /*
     * This adds a child CommandBuilder to your command builder
     * Parameter - CommandBuilder (childBuilder): the child command builder to add
     * Returns - CommandBuilder: the parent command builder
     */
    fun then(childBuilder);

    /*
     * Creates an argument builder from a map.
     * The map must contain a 'name' key as a String that is the name of the command,
     * the map then can contain 'subcommands' as a map which contains the subcommands,
     * the key of the subcommands is the name of the subcommand, and the value is a map,
     * if the name is encased in '<' and '>' it will be treated as an argument, otherwise it will be treated as a literal.
     * You can chain arguments by leaving a space in the name like: 'literal <arg>'.
     * If the key has no name and is just an empty string the value will be used as the function
     * which will be executed when the command is executed, the function should have the appropriate
     * number of parameters, the number of parameters is determined by the number of arguments.
     * Argument types are defined in the main map under the key 'arguments' with the value of a map
     * the keys of this map should be the names of your arguments used in your subcommands,
     * this should be a map and must have the key 'type' which should be a string that is the type of the argument.
     * Optionally if the type is of 'integer' or 'double' you can also have the key 'min' and 'max' with numbers as the value,
     * and if the type is of 'enum' you must have the key 'enum' with the enum class type as the value: 'enum': MyEnum.type.
     * You can also optionally have 'suggests' which has the value of a list of strings that are suggestions for the argument.
     * You can also optionally have 'suggester' which has the value of a function that will be called to get suggestions for the argument,
     * this function should have arbitrary number of parameters which will be the arguments that the user has entered so far.
     * The possible argument types are: 'PlayerName', 'Word', 'GreedyString', 'Double', 'Integer', 'Boolean', 'Enum',
     * 'ItemStack', 'Particle', 'RecipeId', 'EntityId', 'EnchantmentId'
     * Parameter - Map (argumentMap): the map of arguments
     * Returns - CommandBuilder: the argument builder
     */
    static fun fromMap(argumentMap);

    /*
     * Creates an argument builder with a specific argument type, and a name
     * to see all the different types refer to CommandBuilder.fromMap(...)
     * Parameter - String (argumentName): the name of the argument
     * Parameter - String (argumentType): the type of the argument
     * Returns - CommandBuilder: the argument builder
     */
    static fun argument(argumentName, argumentType);

    /*
     * Creates an argument builder with a specific argument type, a name, and a default value
     * to see all the different types refer to CommandBuilder.fromMap(...)
     * Parameter - String (argumentName): the name of the argument
     * Parameter - String (argumentType): the type of the argument
     * Parameter - List (suggestions): a list of strings for the suggestions for the argument
     * Returns - CommandBuilder: the argument builder
     */
    static fun argument(argumentName, argumentType, suggestions);

    /*
     * Creates a literal argument with just a string
     * Parameter - String (argument): the literal argument
     * Returns - CommandBuilder: the argument builder
     */
    static fun literal(argument);
}

/* Native, implemented in Java
 * This class represents an item stack. It can be used to create new item stacks, or to modify existing ones.
 * Import with 'import ItemStack from Minecraft'
 */
class ItemStack {
    /*
     * This gets the max stack size of the ItemStack
     * Returns - Number: the max stack size of the ItemStack
     */
    fun getMaxCount();

    /*
     * This gets the NBT data of the ItemStack as a Map
     * Returns - Map: the NBT data of the ItemStack
     */
    fun getNbt();

    /*
     * This sets the custom name of the ItemStack
     * Parameter - Text (customName): the custom name of the ItemStack, this can be text or string
     * Returns - ItemStack: the ItemStack with the new custom name
     */
    fun setCustomName(customName);

    /*
     * This gets the custom name of the ItemStack
     * Returns - String: the custom name of the ItemStack
     */
    fun getCustomName();

    /*
     * This gets the full id of the ItemStack, for example: 'minecraft:diamond_sword'
     * Returns - String: the full id of the ItemStack
     */
    fun getFullId();

    /*
     * This gets the id of the ItemStack, for example: 'diamond_sword'
     * Returns - String: the id of the ItemStack
     */
    fun getId();

    /*
     * This gets the mining speed multiplier of the ItemStack for the given Block,
     * for example a diamond pickaxe on stone would have a higher multiplier than air on stone
     * Parameter - Block (block): the Block to get the mining speed multiplier for
     * Returns - Number: the mining speed multiplier of the ItemStack for the given Block
     */
    fun getMiningSpeedMultiplier(block);

    /*
     * This checks if the ItemStack can be placed as a block
     * Returns - Boolean: true if the ItemStack can be placed as a block, false otherwise
     */
    fun isBlockItem();

    /*
     * This gets the enchantments of the item, in a map containing the
     * id of the enchantment as the key and the level of the enchantment as the value
     * Returns - Map: the enchantments of the item, map may be empty
     */
    fun getEnchantments();

    /*
     * This gets the durability of the item
     * Returns - Number: the durability of the item
     */
    fun getDurability();

    /*
     * This gets the material of the ItemStack
     * Returns - Material: the material of the ItemStack
     */
    fun getMaterial();

    /*
     * This checks if the ItemStack has the same NBT data as the other given ItemStack
     * Parameter - ItemStack (itemStack): the other ItemStack to compare to
     * Returns - Boolean: true if the ItemStack has the same NBT data as the other given ItemStack
     */
    fun isNbtEqual(itemStack);

    /*
     * This gets the translated name of the ItemStack, for example
     * 'diamond_sword' would return 'Diamond Sword' if your language is English
     * Returns - String: the translated name of the ItemStack
     */
    fun getTranslatedName();

    /*
     * This creates an item entity with the item
     * Returns - ItemEntity: the entity of the ItemStack
     * Throws - Error: Item cannot be converted to an ItemEntity
     */
    fun asEntity();

    /*
     * This sets the lore of the ItemStack
     * Parameter - List (lore): the lore of the ItemStack as a list of Text
     * Returns - ItemStack: the ItemStack with the new lore
     */
    fun setItemLore(lore);

    /*
     * This gets the block of the ItemStack
     * Returns - Block: the block item of the ItemStack
     * Throws - Error: Item cannot be converted to a block
     */
    fun asBlock();

    /*
     * This sets the stack size of the ItemStack
     * Parameter - Number (stackSize): the stack size of the ItemStack
     * Returns - ItemStack: the ItemStack with the new stack size
     */
    fun setStackSize(stackSize);

    /*
     * This checks if the ItemStack is stackable
     * Returns - Boolean: true if the ItemStack is stackable, false otherwise
     */
    fun isStackable();

    /*
     * This gets the max durability of the item
     * Returns - Number: the max durability of the item
     */
    fun getMaxDurability();

    /*
     * This sets the NBT data of the ItemStack
     * Parameter - Map (nbtMap): the NBT data of the ItemStack as a map
     * Returns - ItemStack: the ItemStack with the new NBT data
     */
    fun setNbt(nbtMap);

    /*
     * This gets the count of the ItemStack, the amount of items in the stack
     * Returns - Number: the count of the ItemStack
     */
    fun getCount();

    /*
     * This creates an ItemStack from a material or a string
     * Parameter - MaterialLike (material): the material, item stack, block, or string to create the ItemStack from
     * Returns - ItemStack: the new ItemStack instance
     */
    static fun of(material);

    /*
     * This creates an ItemStack from a NBT string
     * Parameter - String (nbtString): the NBT string to create the ItemStack from
     * Returns - ItemStack: the new ItemStack instance
     */
    static fun parse(nbtString);
}


